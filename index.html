<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bridge Scorer - Multi-Device</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700&family=Crimson+Text:wght@400;600&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Crimson Text', serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      min-height: 100vh;
      color: #e8e8e8;
    }

    .app-container {
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem 1rem;
      min-height: 100vh;
    }

    .setup-container {
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 2rem;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    .header {
      text-align: center;
      margin-bottom: 2rem;
    }

    .app-title {
      font-family: 'Playfair Display', serif;
      font-size: 2.5rem;
      font-weight: 700;
      color: #ffd700;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      margin-bottom: 0.5rem;
      letter-spacing: 2px;
    }

    .app-subtitle {
      font-size: 1.1rem;
      color: #b8b8d8;
      font-weight: 400;
      letter-spacing: 2px;
      text-transform: uppercase;
      opacity: 0.9;
    }

    .divider {
      height: 2px;
      background: linear-gradient(90deg, transparent, #ffd700, transparent);
      margin: 1.5rem 0;
    }

    .button-group {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .primary-button, .secondary-button, .submit-score-btn, .view-results-btn {
      width: 100%;
      padding: 1.25rem 2rem;
      border: none;
      border-radius: 12px;
      font-size: 1.2rem;
      font-weight: 600;
      font-family: 'Playfair Display', serif;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      letter-spacing: 1px;
    }

    .primary-button {
      background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
      color: #1a1a2e;
      box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
    }

    .primary-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4);
    }

    .secondary-button {
      background: rgba(255, 215, 0, 0.1);
      border: 2px solid rgba(255, 215, 0, 0.4);
      color: #ffd700;
    }

    .secondary-button:hover {
      background: rgba(255, 215, 0, 0.2);
      border-color: #ffd700;
      transform: translateY(-2px);
    }

    .logout-button {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 0.5rem 1rem;
      background: rgba(244, 67, 54, 0.2);
      border: 2px solid rgba(244, 67, 54, 0.5);
      color: #f44336;
      font-size: 0.9rem;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 1000;
    }

    .logout-button:hover {
      background: rgba(244, 67, 54, 0.3);
      border-color: #f44336;
      transform: translateY(-2px);
    }

    .config-section {
      margin-bottom: 2rem;
    }

    .section-title {
      font-family: 'Playfair Display', serif;
      font-size: 1.3rem;
      color: #ffd700;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .boards-selector {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
    }

    .board-option, .table-option {
      padding: 0.75rem 1.5rem;
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 215, 0, 0.3);
      border-radius: 8px;
      color: #e8e8e8;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1.1rem;
      font-family: 'Crimson Text', serif;
      font-weight: 600;
    }

    .board-option:hover, .table-option:hover {
      background: rgba(255, 215, 0, 0.1);
      border-color: rgba(255, 215, 0, 0.5);
    }

    .board-option.active, .table-option.active {
      background: rgba(255, 215, 0, 0.2);
      border-color: #ffd700;
      color: #ffd700;
    }

    .game-id-display {
      text-align: center;
      padding: 2rem;
      background: rgba(255, 215, 0, 0.05);
      border: 2px solid rgba(255, 215, 0, 0.3);
      border-radius: 12px;
      margin-bottom: 2rem;
    }

    .game-id-label {
      font-size: 1rem;
      color: #b8b8d8;
      margin-bottom: 0.5rem;
    }

    .game-id-code {
      font-family: 'Playfair Display', serif;
      font-size: 3rem;
      font-weight: 700;
      color: #ffd700;
      letter-spacing: 8px;
      margin-bottom: 1rem;
    }

    .game-id-instruction {
      font-size: 1rem;
      color: #e8e8e8;
      line-height: 1.6;
    }

    .info-box {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 215, 0, 0.2);
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 2rem;
    }

    .info-box p {
      margin-bottom: 0.5rem;
      line-height: 1.6;
    }

    .info-box strong {
      color: #ffd700;
    }

    .form-section {
      margin-bottom: 2rem;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-label {
      display: block;
      font-size: 1rem;
      color: #b8b8d8;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .form-input, .form-select {
      width: 100%;
      padding: 0.875rem 1rem;
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 215, 0, 0.2);
      border-radius: 8px;
      color: #e8e8e8;
      font-size: 1.1rem;
      font-family: 'Crimson Text', serif;
      transition: all 0.3s ease;
    }

    .form-input:focus, .form-select:focus {
      outline: none;
      border-color: #ffd700;
      background: rgba(255, 255, 255, 0.08);
    }

    .form-select option {
      background: #1a1a2e;
      color: #e8e8e8;
    }

    .large-input {
      font-size: 1.5rem;
      text-align: center;
      letter-spacing: 4px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .table-selector {
      display: flex;
      gap: 1rem;
    }

    .table-option {
      flex: 1;
    }

    .table-option.locked {
      opacity: 0.5;
      cursor: not-allowed;
      border-color: rgba(244, 67, 54, 0.3);
    }

    .table-option.locked:hover {
      background: rgba(244, 67, 54, 0.1);
      border-color: rgba(244, 67, 54, 0.5);
      transform: none;
    }

    .players-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
    }

    .player-input-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .position-label-input {
      font-size: 0.9rem;
      color: #ffd700;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .game-container {
      display: grid;
      gap: 1.5rem;
    }

    .round-header {
      background: rgba(255, 215, 0, 0.1);
      border: 2px solid rgba(255, 215, 0, 0.3);
      border-radius: 12px;
      padding: 1.5rem;
    }

    .round-info {
      text-align: center;
    }

    .game-id-small {
      font-size: 0.9rem;
      color: #b8b8d8;
      margin-bottom: 0.5rem;
    }

    .round-title {
      font-family: 'Playfair Display', serif;
      font-size: 1.5rem;
      color: #ffd700;
      font-weight: 600;
    }

    .table-card {
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 215, 0, 0.2);
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .table-header {
      font-family: 'Playfair Display', serif;
      font-size: 1.5rem;
      color: #ffd700;
      margin-bottom: 1rem;
      text-align: center;
      font-weight: 600;
    }

    .table-layout {
      position: relative;
      aspect-ratio: 1;
      margin: 1.5rem auto;
      max-width: 280px;
    }

    .player-badge {
      position: absolute;
      background: rgba(255, 255, 255, 0.08);
      border: 2px solid rgba(255, 215, 0, 0.3);
      border-radius: 8px;
      padding: 0.75rem 1rem;
      text-align: center;
      transition: all 0.3s ease;
    }

    .player-badge.north {
      top: 0;
      left: 50%;
      transform: translateX(-50%);
    }

    .player-badge.south {
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
    }

    .player-badge.east {
      right: 0;
      top: 50%;
      transform: translateY(-50%);
    }

    .player-badge.west {
      left: 0;
      top: 50%;
      transform: translateY(-50%);
    }

    .position-label {
      font-family: 'Playfair Display', serif;
      font-size: 0.75rem;
      color: #ffd700;
      font-weight: 600;
      margin-bottom: 0.25rem;
      letter-spacing: 1px;
    }

    .player-name {
      color: #e8e8e8;
      font-size: 0.95rem;
      white-space: nowrap;
    }

    .board-scoring {
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 1px solid rgba(255, 215, 0, 0.2);
    }

    .scoring-title {
      font-family: 'Playfair Display', serif;
      font-size: 1.2rem;
      color: #ffd700;
      margin-bottom: 1rem;
    }

    .score-form {
      display: grid;
      gap: 1rem;
    }

    /* Button groups for score entry */
    .board-buttons, .declarer-buttons, .level-buttons, .strain-buttons, .double-buttons {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    
    .tricks-buttons {
      display: grid;
      grid-template-columns: repeat(7, auto);
      gap: 0.5rem;
      justify-content: start;
    }

    .board-btn, .declarer-btn, .level-btn, .strain-btn, .double-btn, .tricks-btn {
      padding: 0.75rem 1rem;
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 215, 0, 0.2);
      border-radius: 8px;
      color: #e8e8e8;
      font-size: 1rem;
      font-family: 'Crimson Text', serif;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 600;
    }

    .board-btn:hover, .declarer-btn:hover, .level-btn:hover, .strain-btn:hover, .double-btn:hover, .tricks-btn:hover {
      background: rgba(255, 215, 0, 0.1);
      border-color: rgba(255, 215, 0, 0.5);
      transform: translateY(-1px);
    }

    .board-btn.selected, .declarer-btn.selected, .level-btn.selected, .strain-btn.selected, .double-btn.selected, .tricks-btn.selected {
      background: rgba(255, 215, 0, 0.25);
      border-color: #ffd700;
      color: #ffd700;
    }

    .board-btn.recorded {
      background: rgba(76, 175, 80, 0.1);
      border-color: rgba(76, 175, 80, 0.4);
    }

    .board-btn.recorded.selected {
      background: rgba(76, 175, 80, 0.25);
      border-color: #4caf50;
      color: #4caf50;
    }

    .board-btn {
      flex: 1;
      min-width: 60px;
    }

    .declarer-btn {
      flex: 1;
      font-size: 0.9rem;
    }

    .level-btn {
      width: 46px;
      height: 50px;
      font-size: 1.3rem;
    }

    .strain-btn {
      width: 60px;
      height: 60px;
      font-size: 2rem;
      padding: 0.5rem;
    }

    .strain-btn.clubs {
      color: #4caf50;
    }

    .strain-btn.clubs.selected {
      color: #4caf50;
      border-color: #4caf50;
      background: rgba(76, 175, 80, 0.2);
    }

    .strain-btn.diamonds {
      color: #ff9800;
    }

    .strain-btn.diamonds.selected {
      color: #ff9800;
      border-color: #ff9800;
      background: rgba(255, 152, 0, 0.2);
    }

    .strain-btn.hearts {
      color: #f44336;
    }

    .strain-btn.hearts.selected {
      color: #f44336;
      border-color: #f44336;
      background: rgba(244, 67, 54, 0.2);
    }

    .strain-btn.spades {
      color: #2196f3;
    }

    .strain-btn.spades.selected {
      color: #2196f3;
      border-color: #2196f3;
      background: rgba(33, 150, 243, 0.2);
    }

    .strain-btn.notrump {
      font-size: 1.2rem;
    }

    .double-btn {
      flex: 1;
    }

    .tricks-btn {
      width: 45px;
      height: 45px;
      padding: 0.5rem;
    }

    .submit-score-btn {
      padding: 1rem 1.5rem;
      font-size: 1.1rem;
      background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
      color: #1a1a2e;
    }

    .submit-score-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
    }

    .recorded-scores {
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 1px solid rgba(255, 215, 0, 0.2);
    }

    .recorded-title {
      font-size: 1rem;
      color: #ffd700;
      margin-bottom: 0.75rem;
      font-weight: 600;
    }

    .score-item {
      padding: 0.75rem;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 215, 0, 0.2);
      border-radius: 6px;
      margin-bottom: 0.5rem;
      font-size: 0.95rem;
    }

    .round-complete-banner {
      margin-top: 1.5rem;
      padding: 1.5rem;
      background: rgba(76, 175, 80, 0.2);
      border: 2px solid rgba(76, 175, 80, 0.5);
      border-radius: 8px;
      text-align: center;
    }

    .round-complete-banner p {
      color: #4caf50;
      font-weight: 600;
      margin-bottom: 1rem;
      font-size: 1.1rem;
    }

    .view-results-btn {
      padding: 0.875rem 1.5rem;
      font-size: 1rem;
      background: linear-gradient(135deg, #4caf50 0%, #66bb6a 100%);
      color: white;
    }

    .view-results-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
    }

    .results-header {
      text-align: center;
      margin-bottom: 2rem;
    }

    .results-title {
      font-family: 'Playfair Display', serif;
      font-size: 2rem;
      font-weight: 700;
      color: #ffd700;
      margin-bottom: 0.5rem;
    }

    .leaderboard-card, .movement-card {
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 215, 0, 0.2);
      border-radius: 16px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .leaderboard-title, .movement-title {
      font-family: 'Playfair Display', serif;
      font-size: 1.5rem;
      color: #ffd700;
      margin-bottom: 1.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      justify-content: center;
    }

    .movement-title {
      font-size: 1.3rem;
    }

    .leaderboard-list {
      display: grid;
      gap: 0.75rem;
    }

    .leaderboard-item {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 215, 0, 0.2);
      border-radius: 8px;
      transition: all 0.3s ease;
    }

    .leaderboard-item.rank-1 {
      border-color: #ffd700;
      background: rgba(255, 215, 0, 0.1);
    }

    .leaderboard-item.rank-2 {
      border-color: #c0c0c0;
      background: rgba(192, 192, 192, 0.05);
    }

    .leaderboard-item.rank-3 {
      border-color: #cd7f32;
      background: rgba(205, 127, 50, 0.05);
    }

    .rank-badge {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255, 215, 0, 0.2);
      border: 2px solid rgba(255, 215, 0, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 1.1rem;
      color: #ffd700;
      flex-shrink: 0;
    }

    .rank-1 .rank-badge {
      background: rgba(255, 215, 0, 0.3);
      border-color: #ffd700;
    }

    .player-info {
      flex: 1;
    }

    .player-name-lb {
      font-size: 1.1rem;
      font-weight: 600;
      color: #e8e8e8;
    }

    .imps-score {
      font-family: 'Playfair Display', serif;
      font-size: 1.3rem;
      font-weight: 700;
    }

    .imps-score.positive {
      color: #4caf50;
    }

    .imps-score.negative {
      color: #f44336;
    }

    .movement-list {
      display: grid;
      gap: 0.5rem;
    }

    .movement-item {
      padding: 0.875rem;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 215, 0, 0.2);
      border-radius: 6px;
      font-size: 1rem;
    }

    .action-buttons {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .hidden {
      display: none;
    }

    @media (max-width: 600px) {
      .app-container {
        padding: 1rem 0.5rem;
      }

      .setup-container, .table-card {
        padding: 1.5rem 1rem;
      }

      .app-title {
        font-size: 2rem;
      }

      .game-id-code {
        font-size: 2rem;
        letter-spacing: 4px;
      }

      .table-layout {
        max-width: 220px;
      }

      .player-badge {
        padding: 0.5rem 0.75rem;
      }

      .player-name {
        font-size: 0.85rem;
      }
    }
    
    /* Toast notifications */
    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 10000;
      animation: slideIn 0.3s ease;
      max-width: 300px;
    }
    
    .toast.success {
      border-left: 4px solid #4caf50;
    }
    
    .toast.error {
      border-left: 4px solid #f44336;
    }
    
    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(400px);
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <div id="app" class="app-container"></div>
  <div id="version-badge" style="position: fixed; bottom: 10px; right: 10px; background: rgba(0, 0, 0, 0.7); color: #888; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.7rem; font-family: monospace; z-index: 999; cursor: pointer;" onclick="this.style.display='none'"></div>

  <script>
    const API_URL = window.location.origin + '/api';
    
    // State
    let state = {
      screen: 'start',
      gameId: '',
      tableNumber: null,
      sessionId: Math.random().toString(36).substring(2, 15), // Unique session ID for this browser tab
      adminToken: null, // Admin token for game management access
      isManagementMode: false, // Whether we're editing from management screen
      boardsPerRound: 4,
      showVPs: true, // Whether to display VPs in results
      impBonus: 0, // IMP bonus for winning team (0 or 3)
      currentRound: 1,
      tablePlayers: { north: '', south: '', east: '', west: '' },
      gameData: null,
      joinGameIdInput: '',
      joinTableInput: '',
      managementGameIdInput: '',
      managementAdminTokenInput: '',
      scoreForm: { 
        board: 1, 
        level: null,
        strain: null,
        double: '',
        declarer: '', 
        tricksTaken: null
      },
      version: null // Build version info
    };

    // Movement pattern
    // 8-player individual movement - players numbered 1-8
    // Movement pattern from bridge book:
    // Table 1: N stays, S→2E, E→1S, W→2W
    // Table 2: N→1E, S→2N, E→1W, W→2S
    const movement = {
      table1: {
        north: { table: 1, position: 'north' },   // N stays put
        south: { table: 2, position: 'east' },    // S → 2E
        east: { table: 1, position: 'south' },    // E → 1S
        west: { table: 2, position: 'west' }      // W → 2W
      },
      table2: {
        north: { table: 1, position: 'east' },    // N → 1E
        south: { table: 2, position: 'north' },   // S → 2N
        east: { table: 1, position: 'west' },     // E → 1W
        west: { table: 2, position: 'south' }     // W → 2S
      }
    };

    // Auto-sync interval
    let syncInterval = null;
    let managementRefreshInterval = null;
    let isUserTyping = false;
    let typingTimeout = null;

    // Track when user is typing
    function onUserInput() {
      isUserTyping = true;
      clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => {
        isUserTyping = false;
      }, 3000); // Consider user stopped typing after 3 seconds of inactivity
    }

    // API Functions
    async function accessGameManagement() {
      if (!state.managementGameIdInput) {
        alert('Please enter a Game ID');
        return;
      }
      
      try {
        // First, try to fetch with management flag to check lock
        const checkResponse = await fetch(`${API_URL}/games/${state.managementGameIdInput}?management=true`, {
          headers: {
            'X-Management-Session-Id': state.sessionId
          }
        });
        
        if (checkResponse.status === 423) {
          alert('Game management is currently in use by another session. Please try again later.');
          return;
        }
        
        if (!checkResponse.ok) {
          if (checkResponse.status === 404) {
            alert('Game not found. Please check the Game ID.');
          } else {
            alert('Error accessing game management');
          }
          return;
        }
        
        const data = await checkResponse.json();
        
        // Acquire the management lock
        const lockResponse = await fetch(`${API_URL}/games/${state.managementGameIdInput}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
            'X-Session-Id': state.sessionId
          },
          body: JSON.stringify({
            managementSessionId: state.sessionId
          })
        });
        
        if (!lockResponse.ok) {
          if (lockResponse.status === 423) {
            alert('Game management was just locked by another session. Please try again.');
          } else {
            alert('Failed to acquire management lock');
          }
          return;
        }
        
        const lockedData = await lockResponse.json();
        
        // Set up state for management mode
        state.gameId = state.managementGameIdInput;
        state.gameData = lockedData;
        state.boardsPerRound = lockedData.boardsPerRound;
        state.showVPs = lockedData.showVPs !== undefined ? lockedData.showVPs : true;
        state.impBonus = lockedData.impBonus !== undefined ? lockedData.impBonus : 0;
        state.currentRound = lockedData.currentRound;
        state.isManagementMode = true;
        state.adminToken = lockedData.adminToken; // Keep for admin API calls
        
        // Save to localStorage
        localStorage.setItem('bridgeScorerState', JSON.stringify({
          gameId: state.gameId,
          adminToken: state.adminToken,
          isManagementMode: true,
          managementGameIdInput: state.managementGameIdInput
        }));
        
        changeScreen('gameManagement');
        showToast('Game management accessed');
      } catch (error) {
        console.error('Error accessing management:', error);
        alert('Failed to access game management');
      }
    }
    
    async function createGame() {
      console.log('createGame called');
      const gameId = generateGameId();
      const adminToken = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
      
      console.log('Generated gameId:', gameId);
      console.log('API_URL:', API_URL);
      
      const gameData = {
        gameId,
        adminToken,
        boardsPerRound: state.boardsPerRound,
        showVPs: state.showVPs,
        impBonus: state.impBonus,
        currentRound: 1,
        tables: {
          1: { players: {}, scores: {}, sessionId: null },
          2: { players: {}, scores: {}, sessionId: null }
        },
        created: Date.now()
      };

      try {
        console.log('Sending POST request to:', `${API_URL}/games`);
        console.log('Request body:', JSON.stringify(gameData));
        
        const response = await fetch(`${API_URL}/games`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(gameData)
        });

        console.log('Response status:', response.status);
        console.log('Response ok:', response.ok);

        if (!response.ok) {
          const error = await response.json();
          console.error('Failed to create game:', error);
          alert(`Failed to create game: ${error.error || 'Unknown error'}`);
          return;
        }

        const createdGame = await response.json();
        console.log('Game created successfully:', createdGame);

        state.gameId = gameId;
        state.adminToken = adminToken;
        state.gameData = gameData;
        
        // Store admin token in localStorage for this game
        localStorage.setItem(`adminToken_${gameId}`, adminToken);
        
        changeScreen('gameManagement');
      } catch (error) {
        console.error('Error creating game:', error);
        console.error('Error stack:', error.stack);
        alert('Failed to create game. Please check your connection and try again.');
      }
    }

    async function joinGame() {
      if (!state.joinGameIdInput || !state.joinTableInput) {
        alert('Please enter both Game ID and Table Number');
        return;
      }

      try {
        const response = await fetch(`${API_URL}/games/${state.joinGameIdInput.toUpperCase()}`);
        if (response.ok) {
          const data = await response.json();
          
          console.log('=== JOIN ATTEMPT ===');
          console.log('Attempting to join table', state.joinTableInput);
          console.log('Current sessionId on server:', data.tables[state.joinTableInput]?.sessionId);
          console.log('My sessionId:', state.sessionId);
          
          // Check if this table is already locked by another session
          const tableData = data.tables[state.joinTableInput];
          if (tableData.sessionId && tableData.sessionId !== state.sessionId) {
            console.log('❌ BLOCKED: Table is locked by another session');
            alert(`Table ${state.joinTableInput} is already in use by another device. Please choose a different table or wait for the other device to leave.`);
            return;
          }
          
          console.log('✓ Table is available, proceeding to lock');
          
          state.gameId = state.joinGameIdInput.toUpperCase();
          state.tableNumber = parseInt(state.joinTableInput);
          state.gameData = data;
          state.boardsPerRound = data.boardsPerRound;
          state.showVPs = data.showVPs !== undefined ? data.showVPs : true; // Default to true for old games
          state.impBonus = data.impBonus !== undefined ? data.impBonus : 0; // Default to 0 for old games
          state.currentRound = data.currentRound;
          
          // Initialize tablePlayers with empty strings for all positions
          state.tablePlayers = {
            north: data.tables[state.joinTableInput]?.players?.north || '',
            south: data.tables[state.joinTableInput]?.players?.south || '',
            east: data.tables[state.joinTableInput]?.players?.east || '',
            west: data.tables[state.joinTableInput]?.players?.west || ''
          };
          
          // Lock this table immediately by setting the sessionId
          const lockUpdate = {
            tables: {
              [state.tableNumber]: {
                sessionId: state.sessionId
              }
            }
          };
          await fetch(`${API_URL}/games/${state.gameId}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(lockUpdate)
          });
          
          // Verify we actually got the lock (detect race condition)
          console.log('Verifying lock...');
          const verifyResponse = await fetch(`${API_URL}/games/${state.gameId}`);
          const verifyData = await verifyResponse.json();
          console.log('After PATCH, sessionId on server:', verifyData.tables[state.tableNumber].sessionId);
          console.log('My sessionId:', state.sessionId);
          if (verifyData.tables[state.tableNumber].sessionId !== state.sessionId) {
            console.log('VERIFICATION FAILED - someone else got the lock!');
            alert(`Table ${state.tableNumber} was just taken by another device. Please try again.`);
            return;
          }
          console.log('VERIFICATION PASSED - I have the lock');
          
          // Check if all player names are already filled in
          const allPlayersFilled = state.tablePlayers.north && 
                                   state.tablePlayers.south && 
                                   state.tablePlayers.east && 
                                   state.tablePlayers.west;
          
          if (allPlayersFilled) {
            // Players already set - check if this table completed all boards for current round
            const thisTableScores = data.tables[state.tableNumber]?.scores?.[state.currentRound] || {};
            let thisTableComplete = true;
            for (let i = 1; i <= state.boardsPerRound; i++) {
              const boardNum = (state.currentRound - 1) * state.boardsPerRound + i;
              if (!thisTableScores[boardNum]) {
                thisTableComplete = false;
                break;
              }
            }
            
            if (thisTableComplete) {
              // This table already completed the round - go to waiting screen
              console.log('Round already complete, going to roundWaiting');
              changeScreen('roundWaiting'); // This will start polling for roundWaiting
            } else {
              // Not complete - go to playing screen
              console.log('All players already set, skipping to playing screen');
              const startBoard = (state.currentRound - 1) * state.boardsPerRound + 1;
              state.scoreForm = { 
                board: startBoard, 
                level: null,
                strain: null,
                double: '',
                declarer: '', 
                tricksTaken: null
              };
              changeScreen('playing'); // This will stop joinGame polling
            }
          } else {
            // No players set yet - go to tableSetup to enter names
            console.log('Players not set, going to tableSetup');
            changeScreen('tableSetup'); // This will stop joinGame polling
          }
        } else {
          alert('Game not found. Please check the Game ID.');
        }
      } catch (error) {
        alert('Error joining game: ' + error.message);
      }
    }

    async function saveTablePlayers() {
      if (Object.values(state.tablePlayers).some(name => !name.trim())) {
        alert('Please enter all player names');
        return;
      }

      // Build partial update for just this table's data
      const partialUpdate = {
        tables: {
          [state.tableNumber]: {
            players: state.tablePlayers,
            sessionId: state.sessionId
          }
        }
      };
      
      await fetch(`${API_URL}/games/${state.gameId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(partialUpdate)
      });

      // Fetch latest game data
      const response = await fetch(`${API_URL}/games/${state.gameId}`);
      state.gameData = await response.json();
      changeScreen('playing');
    }

    async function recordScore(e) {
      e.preventDefault();
      
      if (!state.scoreForm.level || !state.scoreForm.strain || !state.scoreForm.declarer || state.scoreForm.result === null) {
        // This shouldn't happen since button is disabled, but safety check
        return;
      }

      const contract = buildContractString();
      const score = calculateScore(
        state.scoreForm.level, 
        state.scoreForm.strain, 
        state.scoreForm.double, 
        state.scoreForm.declarer, 
        state.scoreForm.tricksTaken,
        state.scoreForm.board
      );

      // Build partial update for just this table's score
      const partialUpdate = {
        tables: {
          [state.tableNumber]: {
            scores: {
              [state.currentRound]: {
                [state.scoreForm.board]: {
                  contract: contract,
                  declarer: state.scoreForm.declarer,
                  score: score,
                  board: parseInt(state.scoreForm.board),
                  round: state.currentRound,
                  level: state.scoreForm.level,
                  strain: state.scoreForm.strain,
                  double: state.scoreForm.double,
                  result: state.scoreForm.tricksTaken
                }
              }
            }
          }
        }
      };
      
      // Include sessionId when not in management mode (for player authentication)
      if (!state.isManagementMode) {
        partialUpdate.tables[state.tableNumber].sessionId = state.sessionId;
      }
      
      // Build headers
      const headers = { 'Content-Type': 'application/json' };
      if (state.isManagementMode && state.adminToken) {
        headers['X-Admin-Token'] = state.adminToken;
      }
      
      // Use PATCH to merge this score without overwriting other table's data
      await fetch(`${API_URL}/games/${state.gameId}`, {
        method: 'PATCH',
        headers: headers,
        body: JSON.stringify(partialUpdate)
      });

      // Fetch the latest game state to check if round is complete
      const response = await fetch(`${API_URL}/games/${state.gameId}`);
      const updatedGameData = await response.json();
      state.gameData = updatedGameData;
      
      // If in management mode, return to management screen after saving
      if (state.isManagementMode) {
        state.isManagementMode = false;
        state.tableNumber = null;
        changeScreen('gameManagement');
        return;
      }
      
      // Check if THIS table has completed all boards for this round
      const thisTableScores = updatedGameData.tables[state.tableNumber]?.scores?.[state.currentRound] || {};
      let thisTableComplete = true;
      for (let i = 1; i <= state.boardsPerRound; i++) {
        const boardNum = (state.currentRound - 1) * state.boardsPerRound + i;
        if (!thisTableScores[boardNum]) {
          thisTableComplete = false;
          break;
        }
      }
      
      // If this table completed all boards, go to waiting screen
      if (thisTableComplete) {
        changeScreen('roundWaiting'); // This will start polling
        return;
      }
      
      // Otherwise, just advance to next board in current round
      state.scoreForm = {
        board: Math.min(parseInt(state.scoreForm.board) + 1, state.boardsPerRound * state.currentRound),
        level: null,
        strain: null,
        double: '',
        declarer: '',
        tricksTaken: null
      };
      render();
    }

    async function loadGameData() {
      // Handle different game ID sources based on screen
      const gameIdToLoad = state.gameId || (state.screen === 'joinGame' ? state.joinGameIdInput : null);
      
      if (!gameIdToLoad) return;
      
      // Don't sync while user is actively typing
      if (isUserTyping) return;
      
      try {
        const headers = {};
        if (state.tableNumber) {
          headers['X-Table-Number'] = state.tableNumber.toString();
        }
        
        const response = await fetch(`${API_URL}/games/${gameIdToLoad}`, { headers });
        if (response.ok) {
          const data = await response.json();
          
          // For join screen, just update gameData to show table locks
          if (state.screen === 'joinGame') {
            state.gameData = data;
            render();
            return;
          }
          
          // Check if this session has been kicked out (another device took over)
          if (state.tableNumber && data.tables[state.tableNumber].sessionId && 
              data.tables[state.tableNumber].sessionId !== state.sessionId) {
            alert('This table has been taken over by another device. You have been disconnected.');
            stopSync();
            state.screen = 'start';
            state.gameId = '';
            state.tableNumber = null;
            render();
            return;
          }
          
          // Check if both tables completed (for stopping poll on roundWaiting)
          if (state.screen === 'roundWaiting') {
            // First check if OUR table is still complete
            const thisTableScores = data.tables[state.tableNumber]?.scores?.[state.currentRound] || {};
            let thisTableComplete = true;
            for (let i = 1; i <= state.boardsPerRound; i++) {
              const boardNum = (state.currentRound - 1) * state.boardsPerRound + i;
              if (!thisTableScores[boardNum]) {
                thisTableComplete = false;
                break;
              }
            }
            
            // If our table is no longer complete, go back to playing
            if (!thisTableComplete) {
              console.log('Our table no longer complete while on roundWaiting, going back to playing');
              state.gameData = data; // Update gameData so board status is correct
              changeScreen('playing');
              return; // Exit early, render will be called by changeScreen
            }
            
            // Check if both tables completed
            const table1Scores = data.tables?.[1]?.scores?.[state.currentRound] || {};
            const table2Scores = data.tables?.[2]?.scores?.[state.currentRound] || {};
            let bothTablesComplete = true;
            for (let i = 1; i <= state.boardsPerRound; i++) {
              const boardNum = (state.currentRound - 1) * state.boardsPerRound + i;
              if (!table1Scores[boardNum] || !table2Scores[boardNum]) {
                bothTablesComplete = false;
                break;
              }
            }
            
            // Stop polling when both tables finish (stay on roundWaiting, button will appear)
            if (bothTablesComplete) {
              stopSync();
            }
          }
          
          // Check if on playing screen and round is now complete (e.g., score added via management)
          if (state.screen === 'playing' && state.tableNumber) {
            const thisTableScores = data.tables[state.tableNumber]?.scores?.[state.currentRound] || {};
            let thisTableComplete = true;
            for (let i = 1; i <= state.boardsPerRound; i++) {
              const boardNum = (state.currentRound - 1) * state.boardsPerRound + i;
              if (!thisTableScores[boardNum]) {
                thisTableComplete = false;
                break;
              }
            }
            
            // If round just completed, transition to roundWaiting
            if (thisTableComplete) {
              console.log('Round completed while on playing screen, transitioning to roundWaiting');
              changeScreen('roundWaiting');
              return; // Exit early, changeScreen calls render
            }
          }
          
          // Only update if data has actually changed
          if (JSON.stringify(data) !== JSON.stringify(state.gameData)) {
            state.gameData = data;
            // Only update currentRound if we're not on the round end or waiting screens
            // (to prevent confusion when the other table finishes and auto-advances)
            if (state.screen !== 'roundEnd' && state.screen !== 'roundWaiting') {
              state.currentRound = data.currentRound;
            }
            render();
          }
        }
      } catch (error) {
        console.log('Error loading game data:', error);
      }
    }

    function startSync() {
      if (syncInterval) clearInterval(syncInterval);
      
      // Determine polling interval based on current screen
      let interval = null;
      
      if (state.screen === 'joinGame' && state.joinGameIdInput) {
        // Poll every 3 seconds on joinGame screen (to keep table locks updated)
        interval = 3000;
      } else if (state.screen === 'roundWaiting' || state.screen === 'roundEnd') {
        // Poll every 5 seconds while waiting for round advancement
        interval = 5000;
      }
      
      // Only start polling if we determined an interval
      if (interval) {
        syncInterval = setInterval(loadGameData, interval);
      }
    }

    function stopSync() {
      if (syncInterval) {
        clearInterval(syncInterval);
        syncInterval = null;
      }
    }

    async function deleteScore(boardNumber) {
      if (!confirm(`Delete the score for Board ${boardNumber}? You'll be able to re-enter it.`)) {
        return;
      }
      
      try {
        // Build update to remove this specific board's score
        const partialUpdate = {
          tables: {
            [state.tableNumber]: {
              scores: {
                [state.currentRound]: {
                  [boardNumber]: null  // Setting to null will delete it
                }
              },
              sessionId: state.sessionId  // Include sessionId for authorization
            }
          }
        };
        
        // Send PATCH to delete the score
        await fetch(`${API_URL}/games/${state.gameId}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(partialUpdate)
        });
        
        // Fetch updated game data
        const response = await fetch(`${API_URL}/games/${state.gameId}`);
        state.gameData = await response.json();
        
        // Set up the score form for this board and go back to playing
        state.scoreForm = {
          board: boardNumber,
          level: null,
          strain: null,
          double: '',
          declarer: '',
          tricksTaken: null
        };
        
        state.screen = 'playing';
        render();
      } catch (error) {
        alert('Failed to delete score: ' + error.message);
      }
    }

    async function advanceToNextRound() {
      // Sync with backend to get the latest currentRound
      const response = await fetch(`${API_URL}/games/${state.gameId}`);
      let latestData = await response.json();
      
      // Check if both tables completed this round
      const table1Scores = latestData.tables[1]?.scores?.[state.currentRound] || {};
      const table2Scores = latestData.tables[2]?.scores?.[state.currentRound] || {};
      let bothTablesComplete = true;
      for (let i = 1; i <= state.boardsPerRound; i++) {
        const boardNum = (state.currentRound - 1) * state.boardsPerRound + i;
        if (!table1Scores[boardNum] || !table2Scores[boardNum]) {
          bothTablesComplete = false;
          break;
        }
      }
      
      // If both tables completed and we haven't advanced yet, advance the round
      if (bothTablesComplete && latestData.currentRound === state.currentRound && state.currentRound < 7) {
        // Include sessionId to prove we're a valid player
        const roundUpdate = { 
          currentRound: state.currentRound + 1,
          advancedBy: state.sessionId  // Track who advanced it (for logging/debugging)
        };
        
        const headers = { 'Content-Type': 'application/json' };
        
        // If we have a sessionId, include it to prove we're a player
        if (state.sessionId) {
          headers['X-Session-Id'] = state.sessionId;
        }
        // Or if admin, use admin token
        if (state.adminToken) {
          headers['X-Admin-Token'] = state.adminToken;
        }
        
        await fetch(`${API_URL}/games/${state.gameId}`, {
          method: 'PATCH',
          headers: headers,
          body: JSON.stringify(roundUpdate)
        });
        
        // Fetch again to get updated round
        const roundResponse = await fetch(`${API_URL}/games/${state.gameId}`);
        latestData = await roundResponse.json();
      }
      
      state.currentRound = latestData.currentRound;
      state.gameData = latestData;
      
      // Navigate to the playing screen for the current round
      const startBoard = (state.currentRound - 1) * state.boardsPerRound + 1;
      state.scoreForm = { 
        board: startBoard, 
        level: null,
        strain: null,
        double: '',
        declarer: '', 
        tricksTaken: null
      };
      changeScreen('playing');
    }
    
    function showToast(message, type = 'success') {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => {
          document.body.removeChild(toast);
        }, 300);
      }, 3000);
    }

    function generateGameId() {
      return Math.random().toString(36).substring(2, 8).toUpperCase();
    }

    function buildContractString() {
      if (!state.scoreForm.level || !state.scoreForm.strain) return '';
      return `${state.scoreForm.level}${state.scoreForm.strain}${state.scoreForm.double}`;
    }

    function calculateScore(level, strain, double, declarer, tricksTaken, boardNumber) {
      // Calculate bridge score based on contract and result
      const contract = parseInt(level);
      const tricksNeeded = 6 + contract;
      const tricksDiff = tricksTaken - tricksNeeded;
      
      // Determine vulnerability based on board number (pattern repeats every 16 boards)
      // Official duplicate bridge vulnerability pattern:
      const boardMod16 = ((boardNumber - 1) % 16) + 1; // Convert to 1-16 range
      let vulnPattern;
      
      if ([1, 8, 11, 14].includes(boardMod16)) {
        vulnPattern = 'none';
      } else if ([2, 5, 12, 15].includes(boardMod16)) {
        vulnPattern = 'ns';
      } else if ([3, 6, 9, 16].includes(boardMod16)) {
        vulnPattern = 'ew';
      } else if ([4, 7, 10, 13].includes(boardMod16)) {
        vulnPattern = 'both';
      }
      
      // Determine if declarer's side is vulnerable
      const declarerIsNS = (declarer === 'north' || declarer === 'south');
      const vulnerable = (vulnPattern === 'both') || 
                        (vulnPattern === 'ns' && declarerIsNS) ||
                        (vulnPattern === 'ew' && !declarerIsNS);
      
      if (tricksDiff < 0) {
        // Contract failed (went down)
        const undertricks = Math.abs(tricksDiff);
        let penalty = 0;
        
        if (double === '') {
          penalty = vulnerable ? undertricks * 100 : undertricks * 50;
        } else if (double === 'X') {
          // Doubled undertricks
          if (vulnerable) {
            penalty = undertricks === 1 ? 200 : 200 + (undertricks - 1) * 300;
          } else {
            penalty = undertricks === 1 ? 100 : undertricks === 2 ? 300 : 300 + (undertricks - 2) * 300;
          }
        } else if (double === 'XX') {
          // Redoubled undertricks
          if (vulnerable) {
            penalty = undertricks === 1 ? 400 : 400 + (undertricks - 1) * 600;
          } else {
            penalty = undertricks === 1 ? 200 : undertricks === 2 ? 600 : 600 + (undertricks - 2) * 600;
          }
        }
        
        // Return negative for declarer, positive for defenders
        // From NS perspective: if NS declared and went down, they get negative
        // If EW declared and went down, NS gets positive (defenders' score)
        return declarerIsNS ? -penalty : penalty;
      } else {
        // Contract made
        let score = 0;
        
        // Base trick score
        let baseScore = 0;
        if (strain === 'NT') {
          baseScore = 40 + (contract - 1) * 30;
        } else if (strain === 'H' || strain === 'S') {
          baseScore = contract * 30;
        } else {
          baseScore = contract * 20;
        }
        
        if (double === 'X') baseScore *= 2;
        if (double === 'XX') baseScore *= 4;
        
        score += baseScore;
        
        // Game bonus
        if (baseScore >= 100) {
          score += vulnerable ? 500 : 300;
        } else {
          score += 50;
        }
        
        // Slam bonus
        if (contract === 6) {
          score += vulnerable ? 750 : 500;
        } else if (contract === 7) {
          score += vulnerable ? 1500 : 1000;
        }
        
        // Double/redouble bonus
        if (double === 'X') score += 50;
        if (double === 'XX') score += 100;
        
        // Overtrick bonus
        if (tricksDiff > 0) {
          let overtrickValue = 0;
          if (double === '') {
            overtrickValue = (strain === 'H' || strain === 'S' || strain === 'NT') ? 30 : 20;
          } else if (double === 'X') {
            overtrickValue = vulnerable ? 200 : 100;
          } else if (double === 'XX') {
            overtrickValue = vulnerable ? 400 : 200;
          }
          score += tricksDiff * overtrickValue;
        }
        
        // Return positive for declarer's side, negative for opponents
        // From NS perspective: if NS made contract, they get positive
        // If EW made contract, NS gets negative (opponents' score)
        return declarerIsNS ? score : -score;
      }
    }

    function getCurrentPlayerPositions() {
      if (!state.tableNumber || !state.gameData) return state.tablePlayers;
      
      // If we're in round 1, return the original positions
      if (state.currentRound === 1) {
        return state.gameData.tables[state.tableNumber].players;
      }
      
      // Track ALL 8 players through the movement
      // Start with the original seating from round 1
      const table1Original = state.gameData.tables[1]?.players || {};
      const table2Original = state.gameData.tables[2]?.players || {};
      
      // Create a global player tracking object: { playerName: { table, position } }
      let playerLocations = {
        [table1Original.north]: { table: 1, position: 'north' },
        [table1Original.south]: { table: 1, position: 'south' },
        [table1Original.east]: { table: 1, position: 'east' },
        [table1Original.west]: { table: 1, position: 'west' },
        [table2Original.north]: { table: 2, position: 'north' },
        [table2Original.south]: { table: 2, position: 'south' },
        [table2Original.east]: { table: 2, position: 'east' },
        [table2Original.west]: { table: 2, position: 'west' }
      };
      
      // Apply movement for each round
      for (let round = 1; round < state.currentRound; round++) {
        const newPlayerLocations = {};
        
        // For each player, look up where they currently are and where they move to
        Object.keys(playerLocations).forEach(playerName => {
          if (!playerName) return; // Skip empty players
          
          const currentLocation = playerLocations[playerName];
          const tableKey = `table${currentLocation.table}`;
          const destination = movement[tableKey][currentLocation.position];
          
          newPlayerLocations[playerName] = destination;
        });
        
        playerLocations = newPlayerLocations;
      }
      
      // Build the result for the current table
      const result = { north: '', south: '', east: '', west: '' };
      Object.keys(playerLocations).forEach(playerName => {
        const location = playerLocations[playerName];
        if (location.table === state.tableNumber) {
          result[location.position] = playerName;
        }
      });
      
      return result;
    }

    function getBoardNumbersForRound(round, boardsPerRound) {
      // Board numbers increment: Round 1 = 1-4, Round 2 = 5-8, etc.
      const startBoard = (round - 1) * boardsPerRound + 1;
      return Array.from({ length: boardsPerRound }, (_, i) => startBoard + i);
    }

    function checkRoundComplete() {
      if (!state.gameData) return false;
      
      const table1Scores = state.gameData.tables[1]?.scores?.[state.currentRound] || {};
      const table2Scores = state.gameData.tables[2]?.scores?.[state.currentRound] || {};
      
      for (let i = 1; i <= state.boardsPerRound; i++) {
        if (!table1Scores[i] || !table2Scores[i]) {
          return false;
        }
      }
      return true;
    }

    function calculateVPs(impDifference) {
      // Official WBF Continuous VP Scale for 4-board matches
      // Source: https://www.worldbridge.org/wp-content/uploads/2022/12/WBF_VPScales.pdf
      
      const absIMPs = Math.abs(impDifference);
      
      // WBF VP table for 4 boards (caps at 30 IMPs = 20.00 VPs)
      const vpTable = [
        [0, 10.00], [1, 10.61], [2, 11.20], [3, 11.76], [4, 12.29],
        [5, 12.80], [6, 13.28], [7, 13.74], [8, 14.18], [9, 14.60],
        [10, 15.00], [11, 15.38], [12, 15.74], [13, 16.09], [14, 16.42],
        [15, 16.73], [16, 17.03], [17, 17.31], [18, 17.59], [19, 17.84],
        [20, 18.09], [21, 18.33], [22, 18.55], [23, 18.76], [24, 18.97],
        [25, 19.16], [26, 19.34], [27, 19.52], [28, 19.69], [29, 19.85],
        [30, 20.00]
      ];
      
      // Cap at 30 IMPs
      const cappedIMPs = Math.min(absIMPs, 30);
      
      // Find exact match in table
      const winnerVPs = vpTable[cappedIMPs][1];
      const loserVPs = 20 - winnerVPs;
      
      if (impDifference > 0) {
        return { 
          team1VPs: winnerVPs, 
          team2VPs: parseFloat(loserVPs.toFixed(2))
        };
      } else if (impDifference < 0) {
        return { 
          team1VPs: parseFloat(loserVPs.toFixed(2)), 
          team2VPs: winnerVPs
        };
      } else {
        return { team1VPs: 10.00, team2VPs: 10.00 };
      }
    }

    function calculateIMPs(scoreDiff) {
      const impTable = [
        [20, 0], [50, 1], [90, 2], [130, 3], [170, 4],
        [220, 5], [270, 6], [320, 7], [370, 8], [430, 9],
        [500, 10], [600, 11], [750, 12], [900, 13], [1100, 14],
        [1300, 15], [1500, 16], [1750, 17], [2000, 18], [2250, 19],
        [2500, 20], [3000, 21], [3500, 22], [4000, 23], [Infinity, 24]
      ];
      
      const absDiff = Math.abs(scoreDiff);
      for (let [threshold, imps] of impTable) {
        if (absDiff < threshold) {
          return scoreDiff >= 0 ? imps : -imps;
        }
      }
      return 0;
    }
    
    function formatCompactResult(scoreData) {
      // Format: 1♥EX-1 (level, colored suit symbol, declarer, doubling, result)
      // scoreData has: level, strain, declarer, double, result
      if (!scoreData || !scoreData.level || !scoreData.strain || !scoreData.declarer) {
        return null; // Missing required fields
      }
      
      const level = scoreData.level;
      
      // Convert letter codes to symbols if needed
      let strainSymbol;
      if (scoreData.strain === 'C' || scoreData.strain === '♣') strainSymbol = '♣';
      else if (scoreData.strain === 'D' || scoreData.strain === '♦') strainSymbol = '♦';
      else if (scoreData.strain === 'H' || scoreData.strain === '♥') strainSymbol = '♥';
      else if (scoreData.strain === 'S' || scoreData.strain === '♠') strainSymbol = '♠';
      else if (scoreData.strain === 'NT') strainSymbol = 'N';
      else strainSymbol = scoreData.strain; // fallback
      
      const declarer = scoreData.declarer.charAt(0).toUpperCase();
      const doubling = scoreData.double || '';
      
      // Calculate result relative to contract
      const contractTricks = level + 6;
      const tricksTaken = scoreData.result;
      const diff = tricksTaken - contractTricks;
      
      // Format result: show nothing for making exactly, +X for overtricks, -X for undertricks
      let resultStr;
      if (diff === 0) {
        resultStr = ''; // Making exactly - no suffix
      } else if (diff > 0) {
        resultStr = `+${diff}`; // Overtricks
      } else {
        resultStr = `${diff}`; // Undertricks (already has minus sign)
      }
      
      // Build compact string with colored suit (four-color scheme)
      let compact;
      if (strainSymbol === '♥') {
        // Hearts - red
        compact = `<strong>${level}<span style="color: #f44336;">${strainSymbol}</span>${doubling}${declarer}${resultStr}</strong>`;
      } else if (strainSymbol === '♦') {
        // Diamonds - orange
        compact = `<strong>${level}<span style="color: #ff9800;">${strainSymbol}</span>${doubling}${declarer}${resultStr}</strong>`;
      } else if (strainSymbol === '♠') {
        // Spades - blue
        compact = `<strong>${level}<span style="color: #2196f3;">${strainSymbol}</span>${doubling}${declarer}${resultStr}</strong>`;
      } else if (strainSymbol === '♣') {
        // Clubs - green
        compact = `<strong>${level}<span style="color: #4caf50;">${strainSymbol}</span>${doubling}${declarer}${resultStr}</strong>`;
      } else {
        // NT - no color
        compact = `<strong>${level}${strainSymbol}${doubling}${declarer}${resultStr}</strong>`;
      }
      
      // Human readable description
      const strainName = scoreData.strain === 'NT' ? 'NT' : 
                         scoreData.strain === 'C' || scoreData.strain === '♣' ? 'Clubs' :
                         scoreData.strain === 'D' || scoreData.strain === '♦' ? 'Diamonds' :
                         scoreData.strain === 'H' || scoreData.strain === '♥' ? 'Hearts' : 'Spades';
      const doublingName = doubling === 'X' ? ' doubled' : doubling === 'XX' ? ' redoubled' : '';
      const declarerName = scoreData.declarer;
      const resultName = diff > 0 ? `making ${diff} overtrick${diff > 1 ? 's' : ''}` :
                         diff < 0 ? `down ${Math.abs(diff)}` :
                         'making exactly';
      
      return {
        compact,
        description: `${level}${strainName}${doublingName}, ${declarerName} declarer, ${resultName}`
      };
    }
    
    function isRoundComplete(tableNumber, round) {
      if (!state.gameData || !state.gameData.tables[tableNumber]) return false;
      
      const scores = state.gameData.tables[tableNumber].scores?.[round] || {};
      
      // Check if all boards for this round have been played
      for (let i = 1; i <= state.boardsPerRound; i++) {
        const boardNum = (round - 1) * state.boardsPerRound + i;
        if (!scores[boardNum]) {
          return false; // Missing a score
        }
      }
      
      return true; // All boards scored
    }
    
    function canViewFullSummary() {
      // Can view full summary if:
      // 1. We're in admin/management mode, OR
      // 2. Current round is complete (both tables finished)
      if (state.isManagementMode || !state.gameData) return true;
      
      const table1Complete = isRoundComplete(1, state.currentRound);
      const table2Complete = isRoundComplete(2, state.currentRound);
      
      return table1Complete && table2Complete;
    }

    function calculateLeaderboard() {
      if (!state.gameData) return [];

      const playerIMPs = {};
      const playerVPs = {};
      
      // Initialize all players with 0 IMPs and 0 VPs
      for (let tableNum = 1; tableNum <= 2; tableNum++) {
        const players = state.gameData.tables[tableNum]?.players || {};
        Object.values(players).forEach(playerName => {
          if (playerName && !playerIMPs[playerName]) {
            playerIMPs[playerName] = 0;
            playerVPs[playerName] = 0;
          }
        });
      }

      // Process each round (for VPs, we need round totals)
      for (let round = 1; round <= state.currentRound; round++) {
        const table1Scores = state.gameData.tables[1]?.scores?.[round] || {};
        const table2Scores = state.gameData.tables[2]?.scores?.[round] || {}; 
        
        // Get player positions for this specific round
        const table1Positions = getPlayerPositionsForRound(1, round);
        const table2Positions = getPlayerPositionsForRound(2, round);
        
        // Calculate round total IMPs for VP conversion
        let roundIMPsForTeam1 = 0;
        
        // Process each board in this round
        for (let i = 1; i <= state.boardsPerRound; i++) {
          const boardNum = (round - 1) * state.boardsPerRound + i;
          const t1Score = table1Scores[boardNum];
          const t2Score = table2Scores[boardNum];
          
          if (t1Score && t2Score) {
            const scoreDiff = t1Score.score - t2Score.score;
            const imps = calculateIMPs(scoreDiff);
            
            roundIMPsForTeam1 += imps; // Accumulate for VP calculation
            
            if (imps !== 0) {
              // Get the actual players at each position during this round
              const t1NSPlayers = [table1Positions.north, table1Positions.south];
              const t1EWPlayers = [table1Positions.east, table1Positions.west];
              const t2NSPlayers = [table2Positions.north, table2Positions.south];
              const t2EWPlayers = [table2Positions.east, table2Positions.west];
              
              // Award IMPs based on score difference
              // Positive scoreDiff means Table 1 NS scored better than Table 2 NS
              if (imps > 0) {
                // Table 1 NS gains IMPs
                t1NSPlayers.forEach(p => { if (p) playerIMPs[p] = (playerIMPs[p] || 0) + imps; });
                // Table 1 EW loses IMPs
                t1EWPlayers.forEach(p => { if (p) playerIMPs[p] = (playerIMPs[p] || 0) - imps; });
                // Table 2 NS loses IMPs
                t2NSPlayers.forEach(p => { if (p) playerIMPs[p] = (playerIMPs[p] || 0) - imps; });
                // Table 2 EW gains IMPs
                t2EWPlayers.forEach(p => { if (p) playerIMPs[p] = (playerIMPs[p] || 0) + imps; });
              } else {
                const absImps = Math.abs(imps);
                // Table 1 NS loses IMPs
                t1NSPlayers.forEach(p => { if (p) playerIMPs[p] = (playerIMPs[p] || 0) - absImps; });
                // Table 1 EW gains IMPs
                t1EWPlayers.forEach(p => { if (p) playerIMPs[p] = (playerIMPs[p] || 0) + absImps; });
                // Table 2 NS gains IMPs
                t2NSPlayers.forEach(p => { if (p) playerIMPs[p] = (playerIMPs[p] || 0) + absImps; });
                // Table 2 EW loses IMPs
                t2EWPlayers.forEach(p => { if (p) playerIMPs[p] = (playerIMPs[p] || 0) - absImps; });
              }
            }
          }
        }
        
        // After processing all boards in the round, calculate VPs (before bonus)
        const vpResult = calculateVPs(roundIMPsForTeam1);
        
        // Apply IMP bonus to winning team AFTER VP calculation
        const impBonus = state.gameData?.impBonus || 0;
        if (impBonus > 0 && roundIMPsForTeam1 !== 0) {
          const winningTeam = roundIMPsForTeam1 > 0 ? 1 : 2;
          const bonusIMPs = impBonus;
          
          if (winningTeam === 1) {
            // Team 1 gets bonus
            const team1BonusPlayers = [
              table1Positions.north,
              table1Positions.south,
              table2Positions.east,
              table2Positions.west
            ];
            team1BonusPlayers.forEach(p => { if (p) playerIMPs[p] = (playerIMPs[p] || 0) + bonusIMPs; });
          } else {
            // Team 2 gets bonus
            const team2BonusPlayers = [
              table1Positions.east,
              table1Positions.west,
              table2Positions.north,
              table2Positions.south
            ];
            team2BonusPlayers.forEach(p => { if (p) playerIMPs[p] = (playerIMPs[p] || 0) + bonusIMPs; });
          }
        }
        
        // Team 1 = NS at Table 1, EW at Table 2
        const team1Players = [
          table1Positions.north,
          table1Positions.south,
          table2Positions.east,
          table2Positions.west
        ];
        
        // Team 2 = EW at Table 1, NS at Table 2
        const team2Players = [
          table1Positions.east,
          table1Positions.west,
          table2Positions.north,
          table2Positions.south
        ];
        
        // Award VPs
        team1Players.forEach(p => { if (p) playerVPs[p] = (playerVPs[p] || 0) + vpResult.team1VPs; });
        team2Players.forEach(p => { if (p) playerVPs[p] = (playerVPs[p] || 0) + vpResult.team2VPs; });
      }

      return Object.entries(playerIMPs)
        .map(([name, imps]) => ({ name, imps, vps: playerVPs[name] || 0 }))
        .sort((a, b) => b.imps - a.imps); // Sort by IMPs as requested
    }
    
    // Helper function to get player positions at a specific table for a specific round
    function getPlayerPositionsForRound(tableNumber, round) {
      if (!state.gameData) return { north: '', south: '', east: '', west: '' };
      
      // If round 1, return original positions
      if (round === 1) {
        return state.gameData.tables[tableNumber]?.players || { north: '', south: '', east: '', west: '' };
      }
      
      // Track ALL 8 players through the movement
      const table1Original = state.gameData.tables[1]?.players || {};
      const table2Original = state.gameData.tables[2]?.players || {};
      
      // Create a global player tracking object
      let playerLocations = {
        [table1Original.north]: { table: 1, position: 'north' },
        [table1Original.south]: { table: 1, position: 'south' },
        [table1Original.east]: { table: 1, position: 'east' },
        [table1Original.west]: { table: 1, position: 'west' },
        [table2Original.north]: { table: 2, position: 'north' },
        [table2Original.south]: { table: 2, position: 'south' },
        [table2Original.east]: { table: 2, position: 'east' },
        [table2Original.west]: { table: 2, position: 'west' }
      };
      
      // Apply movement for each round up to the target round
      for (let r = 1; r < round; r++) {
        const newPlayerLocations = {};
        
        Object.keys(playerLocations).forEach(playerName => {
          if (!playerName) return;
          
          const currentLocation = playerLocations[playerName];
          const tableKey = `table${currentLocation.table}`;
          const destination = movement[tableKey][currentLocation.position];
          
          newPlayerLocations[playerName] = destination;
        });
        
        playerLocations = newPlayerLocations;
      }
      
      // Build the result for the requested table
      const result = { north: '', south: '', east: '', west: '' };
      Object.keys(playerLocations).forEach(playerName => {
        const location = playerLocations[playerName];
        if (location.table === tableNumber) {
          result[location.position] = playerName;
        }
      });
      
      return result;
    }

    function getMovementInstructions() {
      if (!state.tableNumber || !state.tablePlayers) return [];
      
      const tableKey = `table${state.tableNumber}`;
      const instructions = [];
      
      ['north', 'south', 'east', 'west'].forEach(position => {
        const destination = movement[tableKey][position];
        const playerName = state.tablePlayers[position];
        if (playerName) {
          if (destination.table === state.tableNumber && destination.position === position) {
            instructions.push(`${playerName} (${position[0].toUpperCase()}): Stay at Table ${state.tableNumber} ${position[0].toUpperCase()}`);
          } else {
            instructions.push(`${playerName} (${position[0].toUpperCase()}): Move to Table ${destination.table} ${destination.position[0].toUpperCase()}`);
          }
        }
      });
      
      return instructions;
    }

    function getRecordedScores() {
      if (!state.gameData || !state.tableNumber) return [];
      const scores = state.gameData.tables[state.tableNumber]?.scores?.[state.currentRound] || {};
      return Object.values(scores).sort((a, b) => a.board - b.board);
    }

    // Render functions
    function render() {
      console.log('Render called, current screen:', state.screen);
      const app = document.getElementById('app');
      console.log('App element:', app);
      
      switch (state.screen) {
        case 'start':
          console.log('Rendering start screen...');
          const startHtml = renderStartScreen();
          console.log('Start screen HTML length:', startHtml?.length);
          app.innerHTML = startHtml;
          console.log('App innerHTML set');
          break;
        case 'createGame':
          app.innerHTML = renderCreateGameScreen();
          break;
        case 'gameCreated':
          app.innerHTML = renderGameCreatedScreen();
          break;
        case 'joinGame':
          app.innerHTML = renderJoinGameScreen();
          break;
        case 'tableSetup':
          app.innerHTML = renderTableSetupScreen();
          break;
        case 'playing':
          app.innerHTML = renderPlayingScreen();
          break;
        case 'roundWaiting':
          app.innerHTML = renderRoundWaitingScreen();
          break;
        case 'roundEnd':
          app.innerHTML = renderRoundEndScreen();
          break;
        case 'gameSummary':
          app.innerHTML = renderGameSummaryScreen();
          break;
        case 'accessManagement':
          app.innerHTML = renderAccessManagementScreen();
          break;
        case 'gameManagement':
          app.innerHTML = renderGameManagementScreen();
          break;
      }
      
      // Update version badge
      const versionBadge = document.getElementById('version-badge');
      if (versionBadge && state.version) {
        const shortHash = state.version.buildId === 'dev' ? 'dev' : state.version.buildId.substring(0, 7);
        versionBadge.textContent = `v: ${shortHash}`;
        versionBadge.title = `Build: ${state.version.buildId}\nBranch: ${state.version.gitBranch}\nEnv: ${state.version.environment}\nClick to hide`;
      }
      
      console.log('Calling attachEventListeners...');
      attachEventListeners();
      console.log('Render complete, app.innerHTML length:', app.innerHTML.length);
    }

    function renderStartScreen() {
      return `
        <div class="setup-container">
          <div class="header">
            <h1 class="app-title">Bridge Scorer</h1>
            <p class="app-subtitle">Individual IMP Scoring</p>
          </div>
          <div class="divider"></div>
          <div class="button-group">
            <button class="primary-button" onclick="changeScreen('createGame')">
              Create New Game
            </button>
            <button class="secondary-button" onclick="changeScreen('joinGame')">
              Join Existing Game
            </button>
            <button class="secondary-button" onclick="changeScreen('accessManagement')" style="background: rgba(255, 215, 0, 0.1); border-color: rgba(255, 215, 0, 0.3); color: #ffd700;">
              🎮 Game Management
            </button>
          </div>
        </div>
      `;
    }
    
    function renderAccessManagementScreen() {
      return `
        <div class="setup-container">
          <div class="header">
            <h1 class="app-title">Access Game Management</h1>
            <p class="app-subtitle">Enter Game ID to manage game</p>
          </div>
          <div class="divider"></div>
          <div class="form-group">
            <label class="form-label">Game ID</label>
            <input type="text" 
                   class="form-input large-input" 
                   value="${state.managementGameIdInput || ''}"
                   oninput="state.managementGameIdInput = this.value.toUpperCase()"
                   placeholder="Enter 6-character Game ID"
                   maxlength="6"
                   style="text-transform: uppercase;">
          </div>
          <button class="primary-button" onclick="accessGameManagement()">
            Access Management
          </button>
          ${getBackButton('start')}
        </div>
      `;
    }

    function renderCreateGameScreen() {
      return `
        <div class="setup-container">
          <div class="header">
            <h1 class="app-title">Create Game</h1>
          </div>
          <div class="divider"></div>
          <div class="config-section">
            <h2 class="section-title">Boards per Round</h2>
            <div class="boards-selector">
              ${[1, 2, 3, 4].map(num => `
                <button class="board-option ${state.boardsPerRound === num ? 'active' : ''}" 
                        onclick="setBoardsPerRound(${num})">
                  ${num}
                </button>
              `).join('')}
            </div>
          </div>
          
          <div class="config-section">
            <h2 class="section-title">Victory Points</h2>
            <div style="display: flex; gap: 0.75rem; justify-content: center;">
              <button class="board-option ${state.showVPs ? 'active' : ''}" 
                      onclick="state.showVPs = true; render();">
                Show VPs
              </button>
              <button class="board-option ${!state.showVPs ? 'active' : ''}" 
                      onclick="state.showVPs = false; render();">
                Hide VPs
              </button>
            </div>
          </div>
          
          <div class="config-section">
            <h2 class="section-title">IMP Bonus</h2>
            <div style="display: flex; gap: 0.75rem; justify-content: center;">
              <button class="board-option ${state.impBonus === 0 ? 'active' : ''}" 
                      onclick="state.impBonus = 0; render();">
                No Bonus
              </button>
              <button class="board-option ${state.impBonus === 3 ? 'active' : ''}" 
                      onclick="state.impBonus = 3; render();">
                +3 IMP Bonus
              </button>
            </div>
            <p style="color: #b8b8d8; font-size: 0.85rem; text-align: center; margin-top: 0.5rem;">
              Bonus applied after VP calculation
            </p>
          </div>
          
          <button class="primary-button" onclick="createGame()">
            Create Game
          </button>
          ${getBackButton('start')}
        </div>
      `;
    }

    function renderGameCreatedScreen() {
      return `
        <div class="setup-container">
          <div class="header">
            <h1 class="app-title">Game Created!</h1>
          </div>
          <div class="divider"></div>
          <div class="game-id-display">
            <p class="game-id-label">Game ID:</p>
            <p class="game-id-code">${state.gameId}</p>
            <p class="game-id-instruction">Share this ID with all players. Each table should join using this ID.</p>
          </div>
          <div class="info-box">
            <p><strong>Next Steps:</strong></p>
            <p>1. Have each table enter this Game ID and their table number (1 or 2)</p>
            <p>2. Players at each table will enter their names</p>
            <p>3. Start playing and entering scores</p>
          </div>
          <button class="secondary-button" onclick="changeScreen('joinGame'); state.joinGameIdInput = state.gameId; loadGameDataForJoin();">
            Join This Game
          </button>
        </div>
      `;
    }

    function renderJoinGameScreen() {
      const isTable1Locked = state.gameData?.tables?.[1]?.sessionId && state.gameData.tables[1].sessionId !== state.sessionId;
      const isTable2Locked = state.gameData?.tables?.[2]?.sessionId && state.gameData.tables[2].sessionId !== state.sessionId;
      
      return `
        <div class="setup-container">
          <div class="header">
            <h1 class="app-title">Join Game</h1>
          </div>
          <div class="divider"></div>
          <div class="form-section">
            <div class="form-group">
              <label class="form-label">Game ID</label>
              <input type="text" class="form-input large-input" 
                     placeholder="Enter Game ID" 
                     value="${state.joinGameIdInput}"
                     oninput="onUserInput(); setJoinGameId(this.value)"
                     style="text-transform: uppercase;">
            </div>
            <div class="form-group">
              <label class="form-label">Table Number</label>
              <div class="table-selector">
                <button class="table-option ${state.joinTableInput === '1' ? 'active' : ''} ${isTable1Locked ? 'locked' : ''}" 
                        onclick="setJoinTable('1')"
                        ${isTable1Locked ? 'title="This table is in use by another device"' : ''}>
                  Table 1 ${isTable1Locked ? '🔒' : ''}
                </button>
                <button class="table-option ${state.joinTableInput === '2' ? 'active' : ''} ${isTable2Locked ? 'locked' : ''}" 
                        onclick="setJoinTable('2')"
                        ${isTable2Locked ? 'title="This table is in use by another device"' : ''}>
                  Table 2 ${isTable2Locked ? '🔒' : ''}
                </button>
              </div>
            </div>
          </div>
          <button class="primary-button" onclick="joinGame()">
            Join Game
          </button>
          ${getBackButton('start')}
        </div>
      `;
    }

    function renderTableSetupScreen() {
      return `
        <div class="setup-container">
          <div class="header">
            <h1 class="app-title">Table ${state.tableNumber} Setup</h1>
            <p class="app-subtitle">Game ID: ${state.gameId}</p>
          </div>
          <div class="divider"></div>
          <div class="config-section">
            <h2 class="section-title">Enter Player Names</h2>
            <div class="players-grid">
              ${['north', 'south', 'east', 'west'].map(position => `
                <div class="player-input-group">
                  <label class="position-label-input">${position.charAt(0).toUpperCase() + position.slice(1)}</label>
                  <input type="text" class="form-input" 
                         placeholder="${position.charAt(0).toUpperCase() + position.slice(1)} player name"
                         value="${state.tablePlayers[position] || ''}"
                         oninput="onUserInput()"
                         onchange="setPlayerName('${position}', this.value)">
                </div>
              `).join('')}
            </div>
          </div>
          <button class="primary-button" onclick="saveTablePlayers()">
            Start Playing
          </button>
          <button class="secondary-button" onclick="leaveTableSetup()" style="margin-top: 1rem;">
            ← Back
          </button>
        </div>
      `;
    }

    function renderPlayingScreen() {
      const recordedScores = getRecordedScores();
      const currentPlayers = getCurrentPlayerPositions();
      
      return `
        <div class="game-container">
          <!-- Game ID in top-left corner -->
          <div class="game-id-badge" style="position: fixed; top: 20px; left: 20px; background: rgba(13, 17, 23, 0.95); padding: 0.5rem 1rem; border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.3); font-size: 0.85rem; color: #ffd700; z-index: 999;">
            ${state.gameId}
          </div>
          
          <button class="logout-button" onclick="logoutAndClear()">🚪 Logout</button>
          
          <!-- Compact round info -->
          <div style="text-align: center; margin-bottom: 1.5rem; padding-top: 1rem;">
            <div style="font-size: 1.2rem; font-weight: 600; color: #ffd700;">
              Round ${state.currentRound}/7 • Table ${state.tableNumber}
            </div>
            ${state.isManagementMode ? `
              <div style="font-size: 0.85rem; color: #ff9800; margin-top: 0.5rem;">
                📋 Management Mode - Entering score on behalf of table
              </div>
            ` : ''}
          </div>

          <div class="table-card">
            <form class="score-form" onsubmit="recordScore(event)">
              
              <!-- Board Number Selection -->
              <div class="form-group">
                <label class="form-label">Board Number</label>
                  <div class="board-buttons">
                    ${getBoardNumbersForRound(state.currentRound, state.boardsPerRound).map(boardNum => {
                      const isRecorded = recordedScores.some(s => s.board === boardNum);
                      const isSelected = state.scoreForm.board == boardNum;
                      return `
                        <button type="button" 
                                class="board-btn ${isSelected ? 'selected' : ''} ${isRecorded ? 'recorded' : ''} ${state.isManagementMode ? 'disabled' : ''}" 
                                onclick="${state.isManagementMode ? '' : `setScoreFormBoard(${boardNum})`}"
                                ${state.isManagementMode ? 'disabled' : ''}>
                          ${boardNum} ${isRecorded ? '✓' : ''}
                        </button>
                      `;
                    }).join('')}
                  </div>
                </div>

                <!-- Contract -->
                <div class="form-group">
                  <label class="form-label">Contract</label>
                  
                  <!-- Level (no subheading) -->
                  <div style="margin-bottom: 0.5rem;">
                    <div class="level-buttons">
                      ${[1, 2, 3, 4, 5, 6, 7].map(level => `
                        <button type="button" 
                                class="level-btn ${state.scoreForm.level === level ? 'selected' : ''}" 
                                onclick="setScoreFormLevel(${level})">
                          ${level}
                        </button>
                      `).join('')}
                    </div>
                  </div>
                  
                  <!-- Strain (no subheading) -->
                  <div style="margin-bottom: 0.5rem;">
                    <div class="strain-buttons">
                      <button type="button" 
                              class="strain-btn clubs ${state.scoreForm.strain === 'C' ? 'selected' : ''}" 
                              onclick="setScoreFormStrain('C')">
                        ♣
                      </button>
                      <button type="button" 
                              class="strain-btn diamonds ${state.scoreForm.strain === 'D' ? 'selected' : ''}" 
                              onclick="setScoreFormStrain('D')">
                        ♦
                      </button>
                      <button type="button" 
                              class="strain-btn hearts ${state.scoreForm.strain === 'H' ? 'selected' : ''}" 
                              onclick="setScoreFormStrain('H')">
                        ♥
                      </button>
                      <button type="button" 
                              class="strain-btn spades ${state.scoreForm.strain === 'S' ? 'selected' : ''}" 
                              onclick="setScoreFormStrain('S')">
                        ♠
                      </button>
                      <button type="button" 
                              class="strain-btn notrump ${state.scoreForm.strain === 'NT' ? 'selected' : ''}" 
                              onclick="setScoreFormStrain('NT')">
                        NT
                      </button>
                    </div>
                  </div>
                  
                  <!-- Doubling (no subheading) -->
                  <div>
                    <div class="double-buttons">
                      <button type="button" 
                              class="double-btn ${state.scoreForm.double === 'X' ? 'selected' : ''}" 
                              onclick="toggleDouble('X')">
                        X
                      </button>
                      <button type="button" 
                              class="double-btn ${state.scoreForm.double === 'XX' ? 'selected' : ''}" 
                              onclick="toggleDouble('XX')">
                        XX
                      </button>
                    </div>
                  </div>
                </div>

                <!-- Declarer -->
                <div class="form-group">
                  <label class="form-label">Declarer</label>
                  <div class="declarer-buttons">
                    ${['north', 'south', 'east', 'west'].map(pos => `
                      <button type="button" 
                              class="declarer-btn ${state.scoreForm.declarer === pos ? 'selected' : ''}" 
                              onclick="setScoreFormDeclarer('${pos}')">
                        ${pos[0].toUpperCase()} - ${currentPlayers[pos]}
                      </button>
                    `).join('')}
                  </div>
                </div>

                <!-- Result (replaced Tricks Taken) -->
                <div class="form-group">
                  <label class="form-label">Result</label>
                  ${state.scoreForm.level ? `
                    <div class="tricks-buttons">
                      ${(() => {
                        const level = state.scoreForm.level;
                        const buttons = [];
                        
                        // Down tricks: can go down from contract level to 0 tricks
                        // For example: 7-level contract (13 tricks needed) can be down 1 through down 13
                        const contractTricks = level + 6;
                        for (let down = contractTricks; down >= 1; down--) {
                          const tricks = contractTricks - down;
                          buttons.push(`
                            <button type="button" 
                                    class="tricks-btn ${state.scoreForm.tricksTaken === tricks ? 'selected' : ''}" 
                                    onclick="setScoreFormTricks(${tricks})">
                              -${down}
                            </button>
                          `);
                        }
                        
                        // Made tricks: contract level through 7 (making exactly through overtricks)
                        for (let made = level; made <= 7; made++) {
                          const tricks = made + 6;
                          buttons.push(`
                            <button type="button" 
                                    class="tricks-btn ${state.scoreForm.tricksTaken === tricks ? 'selected' : ''}" 
                                    onclick="setScoreFormTricks(${tricks})">
                              ${made}
                            </button>
                          `);
                        }
                        
                        return buttons.join('');
                      })()}
                    </div>
                  ` : `
                    <div style="color: #888; font-style: italic; padding: 1rem; text-align: center;">
                      Select a contract level first
                    </div>
                  `}
                </div>

                <button type="submit" class="submit-score-btn" 
                        ${!state.scoreForm.strain || !state.scoreForm.declarer || state.scoreForm.result === null ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>
                  Record Score
                </button>
                ${state.isManagementMode ? `
                  <button type="button" class="secondary-button" style="margin-top: 0.5rem;" onclick="cancelManagementEdit()">
                    Cancel & Return to Management
                  </button>
                ` : ''}
              </form>

              <!-- Recorded Scores (hidden for now) -->
              <div class="recorded-scores" style="display: none;">
                <h4 class="recorded-title">Recorded Scores:</h4>
                ${recordedScores.map(score => `
                  <div class="score-item">
                    Board ${score.board}: ${score.contract} by ${score.declarer.charAt(0).toUpperCase() + score.declarer.slice(1)} = ${score.score}
                  </div>
                `).join('')}
              </div>
          </div>
          
          <div style="text-align: center; margin-top: 1.5rem;">
            <button class="secondary-button" onclick="changeScreen('gameSummary')">
              📊 View Summary
            </button>
          </div>
        </div>
      `;
    }

    function renderRoundWaitingScreen() {
      const recordedScores = getRecordedScores();
      
      // Check if both tables are complete
      const table1Scores = state.gameData?.tables?.[1]?.scores?.[state.currentRound] || {};
      const table2Scores = state.gameData?.tables?.[2]?.scores?.[state.currentRound] || {};
      let bothTablesComplete = true;
      for (let i = 1; i <= state.boardsPerRound; i++) {
        const boardNum = (state.currentRound - 1) * state.boardsPerRound + i;
        const t1Score = table1Scores[boardNum];
        const t2Score = table2Scores[boardNum];
        
        // Score exists if it's present (even if hidden)
        if (!t1Score || !t2Score) {
          bothTablesComplete = false;
          break;
        }
      }
      
      return `
        <div class="game-container">
          <button class="logout-button" onclick="logoutAndClear()">🚪 Logout</button>
          <div class="round-header">
            <div class="round-info">
              <div class="game-id-small">Game: ${state.gameId}</div>
              <div class="round-title">Round ${state.currentRound} - Table ${state.tableNumber} Complete!</div>
            </div>
          </div>

          <div class="table-card">
            <h2 class="table-header">Your Scores This Round</h2>
            
            <div class="recorded-scores" style="margin-top: 0;">
              ${recordedScores.map(score => `
                <div class="score-item" style="display: flex; justify-content: space-between; align-items: center;">
                  <span><strong>Board ${score.board}:</strong> ${score.contract} by ${score.declarer.charAt(0).toUpperCase() + score.declarer.slice(1)} = ${score.score >= 0 ? '+' : ''}${score.score}</span>
                  ${!bothTablesComplete ? `
                    <button onclick="deleteScore(${score.board})" 
                            style="padding: 0.5rem 1rem; background: rgba(244, 67, 54, 0.2); border: 2px solid rgba(244, 67, 54, 0.5); 
                                   border-radius: 6px; color: #f44336; cursor: pointer; font-size: 0.9rem; font-weight: 600;
                                   transition: all 0.2s ease; font-family: 'Crimson Text', serif;"
                            onmouseover="this.style.background='rgba(244, 67, 54, 0.3)'; this.style.borderColor='#f44336';"
                            onmouseout="this.style.background='rgba(244, 67, 54, 0.2)'; this.style.borderColor='rgba(244, 67, 54, 0.5)';">
                      ✕ Edit
                    </button>
                  ` : ''}
                </div>
              `).join('')}
            </div>

            ${bothTablesComplete ? `
              <div class="round-complete-banner">
                <p>✓ Both tables have finished!</p>
                <button class="view-results-btn" onclick="changeScreen('roundEnd')">
                  View Results & Movement
                </button>
              </div>
            ` : `
              <div style="margin-top: 1.5rem; padding: 1.5rem; background: rgba(255, 215, 0, 0.1); border: 2px solid rgba(255, 215, 0, 0.3); border-radius: 8px; text-align: center;">
                <p style="color: #ffd700; font-weight: 600; font-size: 1.1rem;">⏳ Waiting for other table to complete...</p>
              </div>
            `}
            
            <div style="text-align: center; margin-top: 1.5rem;">
              <button class="secondary-button" onclick="changeScreen('gameSummary')">
                📊 View Summary
              </button>
            </div>
          </div>
        </div>
      `;
    }

    function renderRoundEndScreen() {
      const leaderboard = calculateLeaderboard();
      const movementInstructions = getMovementInstructions();
      const isGameComplete = state.currentRound >= 7;

      return `
        <div class="game-container">
          <button class="logout-button" onclick="logoutAndClear()">🚪 Logout</button>
          <div class="results-header">
            <h1 class="results-title">
              ${isGameComplete ? 'Final Results' : `Round ${state.currentRound} Complete`}
            </h1>
            <p class="game-id-small">Game: ${state.gameId}</p>
          </div>

          <div class="leaderboard-card">
            <h2 class="leaderboard-title">
              🏆 Leaderboard
            </h2>
            <div class="leaderboard-list">
              ${leaderboard.map((player, index) => `
                <div class="leaderboard-item rank-${index + 1}">
                  <div class="rank-badge">${index + 1}</div>
                  <div class="player-info">
                    <div class="player-name-lb">${player.name}</div>
                  </div>
                  <div class="imps-score ${player.imps >= 0 ? 'positive' : 'negative'}">
                    ${player.imps >= 0 ? '+' : ''}${player.imps} IMPs
                  </div>
                  ${state.showVPs ? `
                    <div style="color: #b8b8d8; font-size: 0.95rem; font-weight: 600; min-width: 80px; text-align: right;">
                      ${player.vps.toFixed(1)} VPs
                    </div>
                  ` : ''}
                </div>
              `).join('')}
            </div>
          </div>

          ${!isGameComplete ? `
            <div class="movement-card">
              <h2 class="movement-title">
                🔀 Movement Instructions for Next Round
              </h2>
              <div class="movement-list">
                ${movementInstructions.map(instruction => `
                  <div class="movement-item">${instruction}</div>
                `).join('')}
              </div>
            </div>
          ` : ''}

          <div class="action-buttons">
            ${!isGameComplete ? `
              <button class="primary-button" onclick="changeScreen('playing')">
                Continue to Round ${state.gameData?.currentRound || state.currentRound + 1}
              </button>
            ` : `
              <button class="primary-button" onclick="startNewGame()">
                New Game
              </button>
            `}
            <button class="secondary-button" onclick="changeScreen('gameSummary')" style="margin-top: 1rem;">
              📊 View Full Game Summary
            </button>
          </div>
        </div>
      `;
    }

    function renderGameSummaryScreen() {
      if (!state.gameData) return '';
      
      // Build round summaries
      const roundSummaries = [];
      
      // Determine max round to show based on permissions
      const maxRound = canViewFullSummary() ? state.currentRound : state.currentRound - 1;
      
      for (let round = 1; round <= maxRound; round++) {
        const table1Scores = state.gameData.tables[1]?.scores?.[round] || {};
        const table2Scores = state.gameData.tables[2]?.scores?.[round] || {};
        
        // Get player positions for this round
        const table1Positions = getPlayerPositionsForRound(1, round);
        const table2Positions = getPlayerPositionsForRound(2, round);
        
        // Team 1 = NS at Table 1 (which equals EW at Table 2)
        // Team 2 = EW at Table 1 (which equals NS at Table 2)
        let team1IMPs = 0;
        let team2IMPs = 0;
        
        const boards = [];
        
        // Get all boards for this round
        for (let i = 1; i <= state.boardsPerRound; i++) {
          const boardNum = (round - 1) * state.boardsPerRound + i;
          const t1Score = table1Scores[boardNum];
          const t2Score = table2Scores[boardNum];
          
          // Calculate IMPs
          let imps = 0;
          if (t1Score && t2Score) {
            const scoreDiff = t1Score.score - t2Score.score;
            imps = calculateIMPs(scoreDiff);
            
            // Positive IMPs means Table 1 NS (Team 1) did better
            team1IMPs += imps;
            team2IMPs -= imps;
          }
          
          boards.push({
            boardNum,
            table1: t1Score,
            table2: t2Score,
            imps
          });
        }
        
        // Calculate VPs for this round
        const vpResult = calculateVPs(team1IMPs);
        
        roundSummaries.push({
          round,
          table1Positions,
          table2Positions,
          team1IMPs,
          team2IMPs,
          team1VPs: vpResult.team1VPs,
          team2VPs: vpResult.team2VPs,
          boards
        });
      }
      
      return `
        <div class="game-container">
          <button class="logout-button" onclick="logoutAndClear()">🚪 Logout</button>
          <div class="results-header">
            <h1 class="results-title">📊 Full Game Summary</h1>
            <p class="game-id-small">Game: ${state.gameId}</p>
          </div>
          
          ${!canViewFullSummary() && state.currentRound > 0 ? `
            <div style="background: rgba(255, 215, 0, 0.1); border: 2px solid rgba(255, 215, 0, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem; text-align: center;">
              <p style="color: #ffd700; font-weight: 600;">ℹ️ Current round (Round ${state.currentRound}) is in progress</p>
              <p style="color: #b8b8d8; font-size: 0.9rem; margin-top: 0.5rem;">Scores will be visible when both tables complete the round</p>
            </div>
          ` : ''}

          ${roundSummaries.length === 0 ? `
            <div class="leaderboard-card">
              <p style="text-align: center; color: #b8b8d8; padding: 2rem;">No boards have been played yet.</p>
            </div>
          ` : roundSummaries.map(summary => `
            <div class="leaderboard-card" style="margin-bottom: 1.5rem;">
              <h2 class="leaderboard-title">Round ${summary.round}</h2>
              
              <!-- Team Summary -->
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                <!-- Team 1 (NS at Table 1 + EW at Table 2) -->
                <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px;">
                  <div style="color: #ffd700; font-weight: 600; margin-bottom: 0.75rem; text-align: center;">Team 1</div>
                  <div style="font-size: 0.9rem; color: #b8b8d8; margin-bottom: 0.5rem; text-align: center;">
                    ${summary.table1Positions.north} & ${summary.table1Positions.south}<br>
                    ${summary.table2Positions.east} & ${summary.table2Positions.west}
                  </div>
                  <div style="font-size: 1.3rem; font-weight: 700; text-align: center; color: ${summary.team1IMPs >= 0 ? '#4caf50' : '#f44336'};">
                    ${summary.team1IMPs >= 0 ? '+' : ''}${summary.team1IMPs} IMPs
                  </div>
                  ${state.showVPs ? `
                    <div style="font-size: 1.1rem; font-weight: 600; text-align: center; color: #b8b8d8; margin-top: 0.25rem;">
                      ${summary.team1VPs.toFixed(1)} VPs
                    </div>
                  ` : ''}
                </div>
                
                <!-- Team 2 (EW at Table 1 + NS at Table 2) -->
                <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px;">
                  <div style="color: #ffd700; font-weight: 600; margin-bottom: 0.75rem; text-align: center;">Team 2</div>
                  <div style="font-size: 0.9rem; color: #b8b8d8; margin-bottom: 0.5rem; text-align: center;">
                    ${summary.table1Positions.east} & ${summary.table1Positions.west}<br>
                    ${summary.table2Positions.north} & ${summary.table2Positions.south}
                  </div>
                  <div style="font-size: 1.3rem; font-weight: 700; text-align: center; color: ${summary.team2IMPs >= 0 ? '#4caf50' : '#f44336'};">
                    ${summary.team2IMPs >= 0 ? '+' : ''}${summary.team2IMPs} IMPs
                  </div>
                  ${state.showVPs ? `
                    <div style="font-size: 1.1rem; font-weight: 600; text-align: center; color: #b8b8d8; margin-top: 0.25rem;">
                      ${summary.team2VPs.toFixed(1)} VPs
                    </div>
                  ` : ''}
                </div>
              </div>
                              
              <!-- Board Details -->
              <div style="border-top: 2px solid rgba(255, 215, 0, 0.3); padding-top: 1rem;">
                <!-- Column Headers -->
                <div style="display: grid; grid-template-columns: 80px 1fr 1fr auto; gap: 1rem; padding: 0 0.75rem 0.5rem 0.75rem; 
                            border-bottom: 1px solid rgba(255, 215, 0, 0.2); margin-bottom: 0.5rem;">
                  <div style="color: #ffd700; font-weight: 600; font-size: 0.85rem;"></div>
                  <div style="color: #ffd700; font-weight: 600; font-size: 0.85rem;">Table 1</div>
                  <div style="color: #ffd700; font-weight: 600; font-size: 0.85rem;">Table 2</div>
                  <div style="color: #ffd700; font-weight: 600; font-size: 0.85rem; text-align: center; min-width: 80px;">Net IMPs</div>
                </div>
                
                <div style="display: grid; gap: 0.75rem;">
                  ${summary.boards.map(board => `
                    <div style="background: rgba(255, 255, 255, 0.03); border: 1px solid rgba(255, 215, 0, 0.15); 
                                border-radius: 6px; padding: 0.75rem;">
                      <div style="display: grid; grid-template-columns: 80px 1fr 1fr auto; gap: 1rem; align-items: center;">
                        <strong style="color: #ffd700;">Board ${board.boardNum}</strong>
                        
                        <!-- Table 1 -->\n                        <div>
                          ${board.table1 ? (board.table1.hidden ? `
                            <span style="color: #888; font-style: italic; font-size: 0.9rem;">🔒 Hidden</span>
                          ` : `
                            <span style="font-size: 0.9rem;">
                              ${(() => {
                                const formatted = formatCompactResult(board.table1);
                                return formatted ? formatted.compact : `<strong>${board.table1.contract}</strong>`;
                              })()}
                            </span>
                            <span style="font-weight: 700; color: ${board.table1.score >= 0 ? '#4caf50' : '#f44336'}; margin-left: 0.5rem;">
                              ${board.table1.score >= 0 ? '+' : ''}${board.table1.score}
                            </span>
                          `) : `
                            <span style="color: #888; font-style: italic; font-size: 0.9rem;">Not played</span>
                          `}
                        </div>
                        
                        <!-- Table 2 (flip sign for Team 1 perspective since they're EW here) -->
                        <div>
                          ${board.table2 ? (board.table2.hidden ? `
                            <span style="color: #888; font-style: italic; font-size: 0.9rem;">🔒 Hidden</span>
                          ` : `
                            <span style="font-size: 0.9rem;">
                              ${(() => {
                                const formatted = formatCompactResult(board.table2);
                                return formatted ? formatted.compact : `<strong>${board.table2.contract}</strong>`;
                              })()}
                            </span>
                            <span style="font-weight: 700; color: ${board.table2.score >= 0 ? '#f44336' : '#4caf50'}; margin-left: 0.5rem;">
                              ${board.table2.score >= 0 ? '-' : '+'}${Math.abs(board.table2.score)}
                            </span>
                          `) : `
                            <span style="color: #888; font-style: italic; font-size: 0.9rem;">Not played</span>
                          `}
                        </div>
                        
                        <!-- IMPs (rightmost) -->
                        <div style="text-align: center; min-width: 80px;">
                          ${board.table1 && board.table2 ? `
                            <span style="font-weight: 700; font-size: 1.1rem; color: ${board.imps > 0 ? '#4caf50' : board.imps < 0 ? '#f44336' : '#b8b8d8'}">
                              ${board.imps > 0 ? '+' : ''}${board.imps} ${Math.abs(board.imps) === 1 ? 'IMP' : 'IMPs'}
                            </span>
                          ` : `
                            <span style="color: #888;">-</span>
                          `}
                        </div>
                      </div>
                    </div>
                  `).join('')}
                </div>
              </div>
            </div>
          `).join('')}

          <div class="action-buttons">
            <button class="secondary-button" onclick="history.back()">
              ← Back
            </button>
          </div>
        </div>
      `;
    }

    function renderGameManagementScreen() {
      if (!state.gameData) return '';
      
      // Build round summaries (similar to game summary, but with edit buttons)
      const roundSummaries = [];
      
      for (let round = 1; round <= state.currentRound; round++) {
        const table1Scores = state.gameData.tables[1]?.scores?.[round] || {};
        const table2Scores = state.gameData.tables[2]?.scores?.[round] || {};
        
        // Get player positions for this round
        const table1Positions = getPlayerPositionsForRound(1, round);
        const table2Positions = getPlayerPositionsForRound(2, round);
        
        // Team 1 = NS at Table 1, EW at Table 2
        // Team 2 = EW at Table 1, NS at Table 2
        let team1IMPs = 0;
        let team2IMPs = 0;
        
        const boards = [];
        
        // Get ALL boards for this round (even if not played)
        for (let i = 1; i <= state.boardsPerRound; i++) {
          const boardNum = (round - 1) * state.boardsPerRound + i;
          const t1Score = table1Scores[boardNum];
          const t2Score = table2Scores[boardNum];
          
          // Calculate IMPs if both scores exist
          let imps = 0;
          if (t1Score && t2Score) {
            const scoreDiff = t1Score.score - t2Score.score;
            imps = calculateIMPs(scoreDiff);
            team1IMPs += imps;
            team2IMPs -= imps;
          }
          
          boards.push({
            boardNum,
            table1: t1Score,
            table2: t2Score,
            imps
          });
        }
        
        // Calculate VPs for this round
        const vpResult = calculateVPs(team1IMPs);
        
        roundSummaries.push({
          round,
          table1Positions,
          table2Positions,
          team1IMPs,
          team2IMPs,
          team1VPs: vpResult.team1VPs,
          team2VPs: vpResult.team2VPs,
          boards
        });
      }
      
      return `
        <div class="game-container">
          <!-- Floating refresh header -->
          <div style="position: sticky; top: 0; z-index: 100; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); 
                      padding: 0.75rem 1rem; border-bottom: 2px solid rgba(255, 215, 0, 0.3); margin: -1.5rem -1.5rem 1rem -1.5rem;
                      display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem;">
            <div style="display: flex; align-items: center; gap: 1rem;">
              <button class="primary-button" onclick="refreshManagementView()" style="padding: 0.5rem 1rem; font-size: 0.9rem;">
                🔄 Refresh
              </button>
              <label style="display: flex; align-items: center; gap: 0.5rem; color: #b8b8d8; font-size: 0.9rem; cursor: pointer; white-space: nowrap;">
                <input type="checkbox" id="auto-refresh-checkbox" onchange="toggleAutoRefresh(this.checked)" 
                       style="cursor: pointer; width: 18px; height: 18px; flex-shrink: 0;">
                Auto-refresh (15s)
              </label>
            </div>
            <div style="color: #ffd700; font-weight: 600; font-size: 0.9rem;">
              Game ID: <span style="cursor: pointer; text-decoration: underline; user-select: all;" 
                      onclick="navigator.clipboard.writeText('${state.gameId}'); showToast('Game ID copied!')"
                      title="Click to copy">${state.gameId}</span>
            </div>
          </div>
          
          <div class="results-header" style="margin-top: 0.25rem; margin-bottom: 0.25rem;">
            <h1 class="results-title" style="margin-bottom: 0; margin-top: 0;">🎮 Game Management</h1>
          </div>

          <!-- Logout buttons (side by side) -->
          <div style="display: flex; gap: 0.75rem; justify-content: center; margin-top: 1rem; margin-bottom: 0.5rem;">
            ${(() => {
              const table1Locked = state.gameData?.tables?.[1]?.sessionId;
              const table2Locked = state.gameData?.tables?.[2]?.sessionId;
              return `
                <button class="secondary-button" 
                        onclick="logoutTable(1)" 
                        ${!table1Locked ? 'disabled' : ''}
                        style="padding: 0.5rem 1rem; font-size: 0.85rem; background: ${table1Locked ? 'rgba(244, 67, 54, 0.2)' : 'rgba(128, 128, 128, 0.2)'}; 
                               border-color: ${table1Locked ? 'rgba(244, 67, 54, 0.5)' : 'rgba(128, 128, 128, 0.5)'}; 
                               color: ${table1Locked ? '#f44336' : '#888'}; 
                               ${!table1Locked ? 'cursor: not-allowed; opacity: 0.5;' : ''}">
                  ${table1Locked ? '🚪 Logout T1' : '🔓 T1 Free'}
                </button>
                <button class="secondary-button" 
                        onclick="logoutTable(2)" 
                        ${!table2Locked ? 'disabled' : ''}
                        style="padding: 0.5rem 1rem; font-size: 0.85rem; background: ${table2Locked ? 'rgba(244, 67, 54, 0.2)' : 'rgba(128, 128, 128, 0.2)'}; 
                               border-color: ${table2Locked ? 'rgba(244, 67, 54, 0.5)' : 'rgba(128, 128, 128, 0.5)'}; 
                               color: ${table2Locked ? '#f44336' : '#888'}; 
                               ${!table2Locked ? 'cursor: not-allowed; opacity: 0.5;' : ''}">
                  ${table2Locked ? '🚪 Logout T2' : '🔓 T2 Free'}
                </button>
              `;
            })()}
          </div>

          ${roundSummaries.map(summary => `
            <div class="leaderboard-card" style="margin-bottom: 1.5rem;">
              <h2 class="leaderboard-title">Round ${summary.round}</h2>
              
              <!-- Team Summary -->
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                <!-- Team 1 -->
                <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px;">
                  <div style="color: #ffd700; font-weight: 600; margin-bottom: 0.75rem; text-align: center;">Team 1</div>
                  <div style="font-size: 0.9rem; color: #b8b8d8; margin-bottom: 0.5rem; text-align: center;">
                    ${summary.table1Positions.north} & ${summary.table1Positions.south}<br>
                    ${summary.table2Positions.east} & ${summary.table2Positions.west}
                  </div>
                  <div style="font-size: 1.3rem; font-weight: 700; text-align: center; color: ${summary.team1IMPs >= 0 ? '#4caf50' : '#f44336'};">
                    ${summary.team1IMPs >= 0 ? '+' : ''}${summary.team1IMPs} IMPs
                  </div>
                  ${state.showVPs ? `
                    <div style="font-size: 1.1rem; font-weight: 600; text-align: center; color: #b8b8d8; margin-top: 0.25rem;">
                      ${summary.team1VPs.toFixed(1)} VPs
                    </div>
                  ` : ''}
                </div>
                
                <!-- Team 2 -->
                <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px;">
                  <div style="color: #ffd700; font-weight: 600; margin-bottom: 0.75rem; text-align: center;">Team 2</div>
                  <div style="font-size: 0.9rem; color: #b8b8d8; margin-bottom: 0.5rem; text-align: center;">
                    ${summary.table1Positions.east} & ${summary.table1Positions.west}<br>
                    ${summary.table2Positions.north} & ${summary.table2Positions.south}
                  </div>
                  <div style="font-size: 1.3rem; font-weight: 700; text-align: center; color: ${summary.team2IMPs >= 0 ? '#4caf50' : '#f44336'};">
                    ${summary.team2IMPs >= 0 ? '+' : ''}${summary.team2IMPs} IMPs
                  </div>
                  ${state.showVPs ? `
                    <div style="font-size: 1.1rem; font-weight: 600; text-align: center; color: #b8b8d8; margin-top: 0.25rem;">
                      ${summary.team2VPs.toFixed(1)} VPs
                    </div>
                  ` : ''}
                </div>
              </div>
                              
              <!-- Board Details -->
              <div style="border-top: 2px solid rgba(255, 215, 0, 0.3); padding-top: 1rem;">
                <!-- Column Headers -->
                <div style="display: grid; grid-template-columns: 80px 1fr 1fr auto auto; gap: 1rem; padding: 0 0.75rem 0.5rem 0.75rem; 
                            border-bottom: 1px solid rgba(255, 215, 0, 0.2); margin-bottom: 0.5rem;">
                  <div style="color: #ffd700; font-weight: 600; font-size: 0.85rem;"></div>
                  <div style="color: #ffd700; font-weight: 600; font-size: 0.85rem;">Table 1</div>
                  <div style="color: #ffd700; font-weight: 600; font-size: 0.85rem;">Table 2</div>
                  <div style="color: #ffd700; font-weight: 600; font-size: 0.85rem; text-align: center; min-width: 80px;">Net IMPs</div>
                  <div style="color: #ffd700; font-weight: 600; font-size: 0.85rem; text-align: center; min-width: 80px;">Actions</div>
                </div>
                
                <div style="display: grid; gap: 0.75rem;">
                  ${summary.boards.map(board => `
                    <div style="background: rgba(255, 255, 255, 0.03); border: 1px solid rgba(255, 215, 0, 0.15); 
                                border-radius: 6px; padding: 0.75rem;">
                      <div style="display: grid; grid-template-columns: 80px 1fr 1fr auto auto; gap: 1rem; align-items: center;">
                        <strong style="color: #ffd700;">Board ${board.boardNum}</strong>
                        
                        <!-- Table 1 -->
                        <div>
                          ${board.table1 ? `
                            <span style="font-size: 0.9rem;">
                              ${(() => {
                                const formatted = formatCompactResult(board.table1);
                                return formatted ? formatted.compact : `<strong>${board.table1.contract}</strong>`;
                              })()}
                            </span>
                            <span style="font-weight: 700; color: ${board.table1.score >= 0 ? '#4caf50' : '#f44336'}; margin-left: 0.5rem;">
                              ${board.table1.score >= 0 ? '+' : ''}${board.table1.score}
                            </span>
                          ` : `
                            <span style="color: #888; font-style: italic; font-size: 0.9rem;">Not played yet</span>
                          `}
                        </div>
                        
                        <!-- Table 2 (flip sign for Team 1 perspective) -->
                        <div>
                          ${board.table2 ? `
                            <span style="font-size: 0.9rem;">
                              ${(() => {
                                const formatted = formatCompactResult(board.table2);
                                return formatted ? formatted.compact : `<strong>${board.table2.contract}</strong>`;
                              })()}
                            </span>
                            <span style="font-weight: 700; color: ${board.table2.score >= 0 ? '#f44336' : '#4caf50'}; margin-left: 0.5rem;">
                              ${board.table2.score >= 0 ? '-' : '+'}${Math.abs(board.table2.score)}
                            </span>
                          ` : `
                            <span style="color: #888; font-style: italic; font-size: 0.9rem;">Not played yet</span>
                          `}
                        </div>
                        
                        <!-- IMPs -->
                        <div style="text-align: center; min-width: 80px;">
                          ${board.table1 && board.table2 ? `
                            <span style="font-weight: 700; font-size: 1.1rem; color: ${board.imps > 0 ? '#4caf50' : board.imps < 0 ? '#f44336' : '#b8b8d8'}">
                              ${board.imps > 0 ? '+' : ''}${board.imps} ${Math.abs(board.imps) === 1 ? 'IMP' : 'IMPs'}
                            </span>
                          ` : `
                            <span style="color: #888;">-</span>
                          `}
                        </div>
                        
                        <!-- Actions -->
                        <div style="text-align: center; min-width: 100px; display: flex; gap: 0.25rem; justify-content: center;">
                          ${board.table1 ? `
                            <button class="edit-button" onclick="deleteScoreFromManagement(1, ${summary.round}, ${board.boardNum})" 
                                    style="font-size: 0.75rem; padding: 0.4rem 0.6rem; background: rgba(244, 67, 54, 0.2); border-color: rgba(244, 67, 54, 0.5); color: #f44336; font-weight: 600;">
                              ✕ T1
                            </button>
                          ` : `
                            <button class="edit-button" onclick="enterScore(1, ${summary.round}, ${board.boardNum})" 
                                    style="font-size: 0.75rem; padding: 0.4rem 0.6rem; background: rgba(76, 175, 80, 0.2); border-color: rgba(76, 175, 80, 0.5); color: #4caf50; font-weight: 600;">
                              + T1
                            </button>
                          `}
                          ${board.table2 ? `
                            <button class="edit-button" onclick="deleteScoreFromManagement(2, ${summary.round}, ${board.boardNum})" 
                                    style="font-size: 0.75rem; padding: 0.4rem 0.6rem; background: rgba(244, 67, 54, 0.2); border-color: rgba(244, 67, 54, 0.5); color: #f44336; font-weight: 600;">
                              ✕ T2
                            </button>
                          ` : `
                            <button class="edit-button" onclick="enterScore(2, ${summary.round}, ${board.boardNum})" 
                                    style="font-size: 0.75rem; padding: 0.4rem 0.6rem; background: rgba(76, 175, 80, 0.2); border-color: rgba(76, 175, 80, 0.5); color: #4caf50; font-weight: 600;">
                              + T2
                            </button>
                          `}
                        </div>
                      </div>
                    </div>
                  `).join('')}
                </div>
              </div>
            </div>
          `).join('')}

          <div class="action-buttons">
            <button class="secondary-button" onclick="logoutAndClear()" style="background: #f44336;">
              🚪 Logout & Clear Data
            </button>
          </div>
        </div>
      `;
    }

    // Game Management helper functions
    async function refreshManagementView() {
      console.log('refreshManagementView called');
      console.log('gameId:', state.gameId);
      console.log('adminToken:', state.adminToken);
      
      if (!state.gameId || !state.adminToken) {
        console.warn('Missing gameId or adminToken, cannot refresh');
        return;
      }
      
      try {
        console.log('Fetching game data...');
        const response = await fetch(`${API_URL}/games/${state.gameId}`, {
          headers: {
            'X-Admin-Token': state.adminToken
          }
        });
        console.log('Response status:', response.status);
        
        if (response.ok) {
          const data = await response.json();
          console.log('Game data refreshed:', data);
          state.gameData = data;
          state.currentRound = data.currentRound;
          render();
        } else {
          alert('Failed to refresh game data');
        }
      } catch (error) {
        console.error('Error refreshing:', error);
        alert('Error refreshing game data');
      }
    }
    
    function toggleAutoRefresh(enabled) {
      if (enabled) {
        // Start auto-refresh every 15 seconds
        managementRefreshInterval = setInterval(() => {
          refreshManagementView();
        }, 15000);
        showToast('Auto-refresh enabled');
      } else {
        // Stop auto-refresh
        if (managementRefreshInterval) {
          clearInterval(managementRefreshInterval);
          managementRefreshInterval = null;
        }
        showToast('Auto-refresh disabled');
      }
    }
    
    async function logoutTable(tableNumber) {
      if (!confirm(`Logout whoever is connected to Table ${tableNumber}? This will clear their table lock and allow someone else to join.`)) {
        return;
      }
      
      try {
        // Clear the table lock by setting sessionId to null
        const headers = {
          'Content-Type': 'application/json',
          'X-Admin-Token': state.adminToken
        };
        
        const clearLockUpdate = {
          tables: {
            [tableNumber]: {
              sessionId: null,
              lockedAt: null
            }
          }
        };
        
        await fetch(`${API_URL}/games/${state.gameId}`, {
          method: 'PATCH',
          headers: headers,
          body: JSON.stringify(clearLockUpdate)
        });
        
        // Refresh the management view
        await refreshManagementView();
        
        showToast(`Table ${tableNumber} logged out`);
      } catch (error) {
        console.error('Error logging out table:', error);
        alert('Failed to logout table');
      }
    }

    function enterScore(tableNumber, round, boardNumber) {
      // Set up state for entering a new score
      state.tableNumber = tableNumber;
      state.currentRound = round;
      state.isManagementMode = true;
      
      // Initialize empty score form
      state.scoreForm = {
        board: boardNumber,
        level: null,
        strain: null,
        double: '',
        declarer: null,
        tricksTaken: null
      };
      
      changeScreen('playing');
    }

    async function deleteScoreFromManagement(tableNumber, round, boardNumber) {
      // Get existing score
      const existingScore = state.gameData.tables[tableNumber]?.scores?.[round]?.[boardNumber];
      
      if (!existingScore) {
        alert('Score not found');
        return;
      }
      
      // Confirm deletion
      if (!confirm(`Delete the score for Table ${tableNumber}, Board ${boardNumber}?\n\nCurrent: ${existingScore.contract} by ${existingScore.declarer} = ${existingScore.score >= 0 ? '+' : ''}${existingScore.score}\n\nThis will allow the table to re-enter the score if needed.`)) {
        return;
      }
      
      try {
        // Delete the score using admin token
        const headers = {
          'Content-Type': 'application/json',
          'X-Admin-Token': state.adminToken
        };
        
        const deleteUpdate = {
          tables: {
            [tableNumber]: {
              scores: {
                [round]: {
                  [boardNumber]: null  // Setting to null deletes it
                }
              }
            }
          }
        };
        
        await fetch(`${API_URL}/games/${state.gameId}`, {
          method: 'PATCH',
          headers: headers,
          body: JSON.stringify(deleteUpdate)
        });
        
        // Refresh the management view
        await refreshManagementView();
        
        showToast(`Score deleted for Board ${boardNumber}`);
      } catch (error) {
        console.error('Error deleting score:', error);
        alert('Failed to delete score');
      }
    }

    function cancelManagementEdit() {
      state.isManagementMode = false;
      state.tableNumber = null;
      changeScreen('gameManagement');
    }

    async function logoutAndClear() {
      if (confirm('Are you sure you want to logout? This will clear all local data including your admin access to this game.')) {
        stopSync();
        
        // Check both current state AND localStorage for locks to clear
        let tableToUnlock = state.tableNumber;
        let gameIdToUnlock = state.gameId;
        let sessionIdToUnlock = state.sessionId;
        let isManagementToUnlock = state.isManagementMode;
        
        // If not in current state, check localStorage
        if (!tableToUnlock || !gameIdToUnlock) {
          try {
            const saved = localStorage.getItem('bridge-scorer-state');
            if (saved) {
              const savedState = JSON.parse(saved);
              tableToUnlock = tableToUnlock || savedState.tableNumber;
              gameIdToUnlock = gameIdToUnlock || savedState.gameId;
              sessionIdToUnlock = sessionIdToUnlock || savedState.sessionId;
              isManagementToUnlock = isManagementToUnlock || savedState.isManagementMode;
            }
          } catch (e) {
            console.error('Error reading saved state:', e);
          }
        }
        
        // If we're in management mode, release the management lock
        if (isManagementToUnlock && gameIdToUnlock && sessionIdToUnlock) {
          try {
            console.log('Releasing management lock:', { gameId: gameIdToUnlock });
            
            await fetch(`${API_URL}/games/${gameIdToUnlock}`, {
              method: 'PATCH',
              headers: { 
                'Content-Type': 'application/json',
                'X-Session-Id': sessionIdToUnlock
              },
              body: JSON.stringify({
                managementSessionId: null  // Release the lock
              })
            });
            
            console.log('Management lock released successfully');
          } catch (error) {
            console.error('Error releasing management lock:', error);
          }
        }
        // If we have a table lock (from either current state or localStorage), clear it on the server
        else if (gameIdToUnlock && tableToUnlock && sessionIdToUnlock) {
          try {
            const headers = { 
              'Content-Type': 'application/json',
              'X-Session-Id': sessionIdToUnlock  // Send current sessionId to authorize the unlock
            };
            
            // If admin, use admin token instead
            if (state.adminToken) {
              delete headers['X-Session-Id'];
              headers['X-Admin-Token'] = state.adminToken;
            }
            
            console.log('Clearing table lock:', { gameId: gameIdToUnlock, table: tableToUnlock });
            
            // Clear the lock
            await fetch(`${API_URL}/games/${gameIdToUnlock}`, {
              method: 'PATCH',
              headers: headers,
              body: JSON.stringify({
                tables: {
                  [tableToUnlock]: {
                    sessionId: null  // Clear the lock
                  }
                }
              })
            });
            
            console.log('Table lock cleared successfully');
          } catch (error) {
            console.error('Error clearing table lock:', error);
          }
        }
        
        clearLocalStorage();
        
        // Reset state completely
        state = {
          screen: 'start',
          gameId: '',
          tableNumber: null,
          sessionId: Math.random().toString(36).substring(2, 15),
          adminToken: null,
          isManagementMode: false,
          boardsPerRound: 4,
          currentRound: 1,
          tablePlayers: { north: '', south: '', east: '', west: '' },
          gameData: null,
          joinGameIdInput: '',
          joinTableInput: '',
          scoreForm: { 
            board: 1, 
            level: null,
            strain: null,
            double: '',
            declarer: '',
            tricksTaken: null
          }
        };
        
        render();
      }
    }

    // Event handlers
    function startNewGame() {
      stopSync();
      clearLocalStorage();
      
      // Reset state
      state = {
        screen: 'start',
        gameId: '',
        tableNumber: null,
        sessionId: Math.random().toString(36).substring(2, 15),
        boardsPerRound: 4,
        currentRound: 1,
        tablePlayers: { north: '', south: '', east: '', west: '' },
        gameData: null,
        joinGameIdInput: '',
        joinTableInput: '',
        scoreForm: { 
          board: 1, 
          level: null,
          strain: null,
          double: '',
          declarer: '', 
          tricksTaken: null
        }
      };
      
      changeScreen('start');
    }
    
    function changeScreen(screen, addToHistory = true) {
      // When navigating to playing screen, sync currentRound from gameData
      // (backend may have auto-advanced it)
      if (screen === 'playing' && state.gameData) {
        state.currentRound = state.gameData.currentRound;
      }
      
      // Update URL hash - this will trigger hashchange event
      if (addToHistory) {
        window.location.hash = screen;
      } else {
        // Replace without adding to history
        window.history.replaceState(null, '', `#${screen}`);
        // Still need to update state and render since hashchange won't fire
        state.screen = screen;
        updatePolling();
        render();
      }
    }
    
    // Listen to hash changes (including back/forward button)
    window.addEventListener('hashchange', () => {
      const screen = window.location.hash.substring(1) || 'start';
      state.screen = screen;
      
      // Sync currentRound when navigating to playing
      if (screen === 'playing' && state.gameData) {
        state.currentRound = state.gameData.currentRound;
      }
      
      updatePolling();
      render();
    });
    
    // Helper to manage polling based on current screen
    function updatePolling() {
      if (state.screen === 'joinGame' && state.joinGameIdInput && state.joinGameIdInput.length >= 6) {
        startSync(); // Poll for table locks if game ID is entered
      } else if (state.screen === 'roundWaiting' || state.screen === 'roundEnd') {
        startSync(); // Poll while waiting for round advancement
      } else {
        stopSync(); // Stop polling on all other screens
      }
    }

    // On page load, initialize from URL hash
    const initialScreen = window.location.hash.substring(1) || 'start';
    if (!window.location.hash) {
      window.location.hash = 'start';
    }

    function getBackButton(destination, text = '← Back') {
      return `
        <button class="secondary-button" onclick="changeScreen('${destination}')" style="margin-top: 1rem;">
          ${text}
        </button>
      `;
    }

    async function leaveTableSetup() {
      // Release the table lock
      if (state.tableNumber && state.gameId && state.sessionId) {
        const headers = {
          'Content-Type': 'application/json',
          'X-Session-Id': state.sessionId  // Send sessionId to authorize the unlock
        };
        
        const releaseUpdate = {
          tables: {
            [state.tableNumber]: {
              sessionId: null
            }
          }
        };
        await fetch(`${API_URL}/games/${state.gameId}`, {
          method: 'PATCH',
          headers: headers,
          body: JSON.stringify(releaseUpdate)
        });
      }
      
      // Reset state
      state.tableNumber = null;
      state.tablePlayers = { north: '', south: '', east: '', west: '' };
      stopSync();
      changeScreen('joinGame');
    }

    function setBoardsPerRound(num) {
      state.boardsPerRound = num;
      render();
    }

    function setJoinGameId(value) {
      state.joinGameIdInput = value.toUpperCase();
      
      // Load game data to check table locks
      if (value.length >= 6) {
        loadGameDataForJoin();
        // Start polling to keep table locks updated
        startSync();
      } else {
        // Stop polling if game ID is cleared/incomplete
        stopSync();
      }
    }

    function loadGameDataForJoin() {
      if (state.joinGameIdInput.length >= 6) {
        fetch(`${API_URL}/games/${state.joinGameIdInput.toUpperCase()}`)
          .then(response => response.ok ? response.json() : null)
          .then(data => {
            if (data) {
              state.gameData = data;
              render();
            }
          })
          .catch(() => {});
      }
    }

    function setJoinTable(value) {
      state.joinTableInput = value;
      render();
    }

    function setPlayerName(position, value) {
      state.tablePlayers[position] = value;
    }

    async function setScoreFormBoard(value) {
      state.scoreForm.board = value;
      
      // Poll once to check for updates (e.g., admin might have completed round)
      if (state.gameId) {
        try {
          const response = await fetch(`${API_URL}/games/${state.gameId}`);
          if (response.ok) {
            const data = await response.json();
            
            // Check if round is now complete
            if (state.tableNumber) {
              const thisTableScores = data.tables[state.tableNumber]?.scores?.[state.currentRound] || {};
              let thisTableComplete = true;
              for (let i = 1; i <= state.boardsPerRound; i++) {
                const boardNum = (state.currentRound - 1) * state.boardsPerRound + i;
                if (!thisTableScores[boardNum]) {
                  thisTableComplete = false;
                  break;
                }
              }
              
              // If round complete, transition to roundWaiting
              if (thisTableComplete) {
                console.log('Round completed, transitioning to roundWaiting');
                state.gameData = data;
                state.screen = 'roundWaiting';
                startSync(); // Start polling to detect when other table finishes
                render();
                return;
              }
            }
            
            // Update game data
            state.gameData = data;
          }
        } catch (error) {
          console.error('Error checking for updates:', error);
        }
      }
      
      // Check if this board already has a score recorded
      const existingScore = state.gameData?.tables?.[state.tableNumber]?.scores?.[state.currentRound]?.[value];
      
      if (existingScore) {
        // Prefill the form with existing data
        console.log('Prefilling form with existing score:', existingScore);
        state.scoreForm.level = existingScore.level;
        state.scoreForm.strain = existingScore.strain;
        state.scoreForm.double = existingScore.double || '';
        state.scoreForm.declarer = existingScore.declarer;
        state.scoreForm.tricksTaken = existingScore.result;
      } else {
        // Clear the form for new entry
        state.scoreForm.level = null;
        state.scoreForm.strain = null;
        state.scoreForm.double = '';
        state.scoreForm.declarer = null;
        state.scoreForm.tricksTaken = null;
      }
      
      render();
    }

    function setScoreFormLevel(value) {
      state.scoreForm.level = value;
      render();
    }

    function setScoreFormStrain(value) {
      state.scoreForm.strain = value;
      render();
    }

    function setScoreFormDouble(value) {
      state.scoreForm.double = value;
      render();
    }

    function toggleDouble(value) {
      // Toggle behavior: clicking selected button unselects it
      if (state.scoreForm.double === value) {
        state.scoreForm.double = '';
      } else {
        state.scoreForm.double = value;
      }
      render();
    }

    function setScoreFormDeclarer(value) {
      state.scoreForm.declarer = value;
      render();
    }

    function setScoreFormTricks(value) {
      state.scoreForm.tricksTaken = value;
      render();
    }

    function setScoreFormContract(value) {
      state.scoreForm.contract = value;
    }

    function setScoreFormScore(value) {
      state.scoreForm.score = value;
    }

    function attachEventListeners() {
      // Event listeners are handled inline with onclick attributes
    }

    // LocalStorage persistence functions
    const STORAGE_KEY = 'bridge-scorer-state';
    
    function saveStateToLocalStorage() {
      try {
        const stateToSave = {
          screen: state.screen,
          gameId: state.gameId,
          tableNumber: state.tableNumber,
          sessionId: state.sessionId,
          adminToken: state.adminToken,  // Save admin token for reconnection
          boardsPerRound: state.boardsPerRound,
          currentRound: state.currentRound,
          tablePlayers: state.tablePlayers,
          joinGameIdInput: state.joinGameIdInput,
          joinTableInput: state.joinTableInput,
          scoreForm: state.scoreForm
        };
        console.log('Saving to localStorage:', stateToSave.screen);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
      } catch (e) {
        console.error('Failed to save state to localStorage:', e);
      }
    }
    
    function loadStateFromLocalStorage() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          const savedState = JSON.parse(saved);
          
          // Only restore game/session data
          state.gameId = savedState.gameId || '';
          state.tableNumber = savedState.tableNumber || null;
          state.sessionId = savedState.sessionId || state.sessionId; // Restore to maintain table lock
          state.adminToken = savedState.adminToken || null;  // Restore admin token
          state.boardsPerRound = savedState.boardsPerRound || 4;
          state.currentRound = savedState.currentRound || 1;
          state.tablePlayers = savedState.tablePlayers || { north: '', south: '', east: '', west: '' };
          state.joinGameIdInput = savedState.joinGameIdInput || '';
          state.joinTableInput = savedState.joinTableInput || '';
          state.scoreForm = savedState.scoreForm || { 
            board: 1, 
            level: null,
            strain: null,
            double: '',
            declarer: '', 
            tricksTaken: null
          };
          
          // Determine screen from URL hash OR infer from saved state
          const urlHash = window.location.hash.substring(1);
          
          if (urlHash) {
            // URL hash exists - use it
            state.screen = urlHash;
          } else if (state.gameId && state.tableNumber) {
            // No hash but we have an active game - default to playing screen
            // (we'll verify/correct this when we fetch game data)
            state.screen = 'playing';
            window.location.hash = 'playing';
          } else if (state.gameId && savedState.isManagementMode) {
            // No hash but we have management mode
            state.screen = 'gameManagement';
            window.location.hash = 'gameManagement';
          } else {
            // No hash, no active game
            state.screen = 'start';
            window.location.hash = 'start';
          }
          
          // If we were in an active game, reconnect
          if (state.gameId && (state.screen === 'playing' || state.screen === 'roundWaiting' || state.screen === 'roundEnd' || state.screen === 'tableSetup' || state.screen === 'gameSummary' || state.screen === 'gameManagement')) {
            // Build headers for fetch
            const headers = {};
            if (state.adminToken && state.screen === 'gameManagement') {
              headers['X-Admin-Token'] = state.adminToken;
            }
            
            // Fetch latest game data
            fetch(`${API_URL}/games/${state.gameId}`, { headers })
              .then(response => response.ok ? response.json() : null)
              .then(data => {
                if (data) {
                  state.gameData = data;
                  
                  console.log('Reconnecting to screen:', state.screen);
                  console.log('Game data loaded:', data.gameId);
                  
                  // If reconnecting to playing screen, check our table's completion status
                  if (state.screen === 'playing' && state.tableNumber) {
                    const thisTableScores = data.tables[state.tableNumber]?.scores?.[state.currentRound] || {};
                    let thisTableComplete = true;
                    for (let i = 1; i <= state.boardsPerRound; i++) {
                      const boardNum = (state.currentRound - 1) * state.boardsPerRound + i;
                      if (!thisTableScores[boardNum]) {
                        thisTableComplete = false;
                        break;
                      }
                    }
                    
                    // If our table completed all boards
                    if (thisTableComplete) {
                      // Check if BOTH tables are complete
                      const table1Scores = data.tables?.[1]?.scores?.[state.currentRound] || {};
                      const table2Scores = data.tables?.[2]?.scores?.[state.currentRound] || {};
                      let bothTablesComplete = true;
                      for (let i = 1; i <= state.boardsPerRound; i++) {
                        const boardNum = (state.currentRound - 1) * state.boardsPerRound + i;
                        if (!table1Scores[boardNum] || !table2Scores[boardNum]) {
                          bothTablesComplete = false;
                          break;
                        }
                      }
                      
                      if (bothTablesComplete) {
                        // Both tables complete - go to roundEnd
                        console.log('Both tables complete on reconnection, going to roundEnd');
                        state.screen = 'roundEnd';
                        window.location.hash = 'roundEnd';
                      } else {
                        // Only our table complete - go to roundWaiting
                        console.log('Our table complete on reconnection, going to roundWaiting');
                        state.screen = 'roundWaiting';
                        window.location.hash = 'roundWaiting';
                      }
                    }
                  }
                  
                  // If reconnecting to roundWaiting, check if our table is still complete
                  if (state.screen === 'roundWaiting' && state.tableNumber) {
                    const thisTableScores = data.tables[state.tableNumber]?.scores?.[state.currentRound] || {};
                    let thisTableComplete = true;
                    for (let i = 1; i <= state.boardsPerRound; i++) {
                      const boardNum = (state.currentRound - 1) * state.boardsPerRound + i;
                      if (!thisTableScores[boardNum]) {
                        thisTableComplete = false;
                        break;
                      }
                    }
                    
                    // If our table is no longer complete, go back to playing
                    if (!thisTableComplete) {
                      console.log('Our table no longer complete on reconnection, going to playing');
                      state.screen = 'playing';
                      window.location.hash = 'playing';
                    }
                  }
                  
                  // Always update currentRound for gameManagement screen
                  if (state.screen === 'gameManagement') {
                    state.currentRound = data.currentRound;
                  }
                  // Only update currentRound if we're not on the round end or waiting screens
                  // (to prevent confusion when reconnecting while viewing results)
                  else if (state.screen !== 'roundEnd' && state.screen !== 'roundWaiting') {
                    state.currentRound = data.currentRound;
                  }
                  
                  // If we were on gameSummary, go to roundEnd instead (can navigate back to summary from there)
                  if (state.screen === 'gameSummary') {
                    state.screen = 'roundEnd';
                    window.location.hash = 'roundEnd';
                  }
                  
                  // Restart sync only on screens that need polling
                  if (state.screen === 'joinGame' && state.joinGameIdInput || state.screen === 'roundWaiting') {
                    startSync();
                  }
                  
                  render();
                  
                  // Show reconnection toast
                  showToast('✓ Reconnected to game');
                } else {
                  // Game not found, go back to start and clear saved state
                  console.log('Game not found, resetting to start');
                  clearLocalStorage();
                  
                  // Reset ALL state to initial values
                  state.screen = 'start';
                  state.gameId = '';
                  state.tableNumber = null;
                  state.sessionId = Math.random().toString(36).substring(2, 15); // New session
                  state.boardsPerRound = 4;
                  state.currentRound = 1;
                  state.tablePlayers = { north: '', south: '', east: '', west: '' };
                  state.gameData = null;
                  state.joinGameIdInput = '';
                  state.joinTableInput = '';
                  state.scoreForm = { 
                    board: 1, 
                    level: null,
                    strain: null,
                    double: '',
                    declarer: '', 
                    tricksTaken: null
                  };
                  
                  render();
                }
              })
              .catch(error => {
                console.error('Failed to reconnect to game:', error);
                clearLocalStorage();
                
                // Reset ALL state to initial values
                state.screen = 'start';
                state.gameId = '';
                state.tableNumber = null;
                state.sessionId = Math.random().toString(36).substring(2, 15); // New session
                state.boardsPerRound = 4;
                state.currentRound = 1;
                state.tablePlayers = { north: '', south: '', east: '', west: '' };
                state.gameData = null;
                state.joinGameIdInput = '';
                state.joinTableInput = '';
                state.scoreForm = { 
                  board: 1, 
                  level: null,
                  strain: null,
                  double: '',
                  declarer: '', 
                  tricksTaken: null
                };
                
                render();
              });
            
            return true; // Indicate we're reconnecting
          }
        }
      } catch (e) {
        console.error('Failed to load state from localStorage:', e);
      }
      return false; // No reconnection needed
    }
    
    function clearLocalStorage() {
      try {
        localStorage.removeItem(STORAGE_KEY);
      } catch (e) {
        console.error('Failed to clear localStorage:', e);
      }
    }

    // Initialize
    console.log('Starting initialization...');
    console.log('State:', state);
    
    // Fetch version info
    fetch(`${API_URL}/version`)
      .then(res => res.json())
      .then(data => {
        state.version = data;
        console.log('Version:', data);
        // Update version badge
        const versionBadge = document.getElementById('version-badge');
        if (versionBadge) {
          const shortHash = data.buildId === 'dev' ? 'dev' : data.buildId.substring(0, 7);
          versionBadge.textContent = `v: ${shortHash}`;
          versionBadge.title = `Build: ${data.buildId}\nBranch: ${data.gitBranch}\nEnv: ${data.environment}\nClick to hide`;
        }
      })
      .catch(err => console.error('Failed to fetch version:', err));
    
    try {
      const isReconnecting = loadStateFromLocalStorage();
      console.log('Reconnecting:', isReconnecting);
      // Always render initially - reconnection will update async
      console.log('Calling initial render...');
      render();
      console.log('Initial render complete');
    } catch (error) {
      console.error('Initialization error:', error);
      // Fallback render
      document.getElementById('app').innerHTML = `
        <div class="setup-container">
          <h1 style="color: red;">Error: ${error.message}</h1>
          <pre>${error.stack}</pre>
        </div>
      `;
    }
    
    // Save state whenever it changes
    const originalRender = render;
    render = function() {
      try {
        originalRender();
        saveStateToLocalStorage();
      } catch (error) {
        console.error('Render error:', error);
      }
    };
  </script>
</body>
</html>
